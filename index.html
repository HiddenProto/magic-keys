<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>KEYBOARD DOOM â€” V3.0 (Checkpoints Fix & More Skins)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<script src="https://cdn.tailwindcss.com"></script>
<style>
/* Global Styles */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#000; overflow:hidden; touch-action:none; font-family: 'Inter', sans-serif; }
canvas { display:block; image-rendering:pixelated; cursor:none; }
#hud { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; color:#fff; }
.topleft { position:absolute; top:10px; left:10px; font-size:14px; text-shadow: 0 0 5px #0f0; }
.centertop { position:absolute; top:10px; left:50%; transform:translateX(-50%); font-size:18px; font-weight:bold; color: #ffeb3b; text-shadow: 0 0 8px #ffeb3b; }
.bottomcenter { position:absolute; bottom:10px; left:50%; transform:translateX(-50%); font-size:12px; opacity:.8; }
.status { position:absolute; top:60px; left:10px; font-size:12px; text-shadow: 0 0 3px #fff; }
/* Menu & Game Over */
.menu, .gameover, .shop, .multiplayer-lobby {
    position:absolute; top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,.95); backdrop-filter: blur(5px);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    color:#fff; transition: opacity 0.3s;
}
.hidden { opacity:0; pointer-events:none; position:absolute; }
.menu h1, .shop h1, .multiplayer-lobby h1 {
    font-size: 2.5rem; margin-bottom: 20px;
    color: #00ff44; text-shadow: 0 0 10px #00ff44;
    text-align: center;
}
.menu button, .shop button, .multiplayer-lobby button {
    background: #1e1e1e; border: 2px solid #00ff44; color: #00ff44;
    padding: 10px 20px; margin: 8px 0; border-radius: 8px;
    cursor: pointer; font-size: 16px; font-weight: bold;
    transition: all 0.2s ease-in-out;
    box-shadow: 0 0 5px #00ff44;
}
.menu button:hover, .shop button:hover, .multiplayer-lobby button:hover {
    background: #00ff44; color: #000; box-shadow: 0 0 15px #00ff44;
    transform: translateY(-2px);
}
.menu button:disabled {
    background: #333; border-color: #555; color: #888; cursor: not-allowed;
    box-shadow: none; transform: none;
}
.error-msg { color: #f55; margin-top: 10px; font-weight: bold; }
/* Keypad Grid (Checkpoints) */
#keypad {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    gap: 8px;
    width: 90vw;
    max-width: 800px;
    padding: 10px;
    background: rgba(30, 30, 30, 0.8);
    border: 1px solid #00ff44;
    border-radius: 10px;
    max-height: 40vh;
    overflow-y: auto;
    margin-top: 10px;
}
.key-btn {
    text-align: center;
    padding: 8px;
    font-size: 14px;
    background: #2a2a2a;
    border: 1px solid #00ff44;
    color: #00ff44;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.1s;
}
.key-btn:hover:not(.locked) {
    background: #00ff44;
    color: #000;
}
.key-btn.locked {
    background: #444;
    border-color: #555;
    color: #888;
    cursor: not-allowed;
    box-shadow: none;
    user-select: none;
}
.key-btn.current {
    background: #ff5500;
    border-color: #ff5500;
    color: #fff;
    box-shadow: 0 0 10px #ff5500;
    animation: pulse 1s infinite alternate;
}
@keyframes pulse {
    from { box-shadow: 0 0 10px #ff5500; }
    to { box-shadow: 0 0 15px #ff5500; }
}
/* Skins Shop Specifics */
.skin-card {
    background: #222;
    border: 1px solid #00ff44;
    border-radius: 8px;
    padding: 15px;
    margin: 10px;
    width: 250px;
    text-align: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 0 5px #00ff44;
}
.skin-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 0 15px #00ff44;
}
.skin-card h3 {
    font-size: 1.2rem;
    color: #ffeb3b;
    margin-bottom: 5px;
}
.skin-card p {
    font-size: 0.85rem;
    color: #bbb;
    min-height: 40px;
    margin-bottom: 10px;
}
.skin-card .preview {
    width: 40px;
    height: 40px;
    margin: 10px auto;
    border: 1px solid #444;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #111;
}
.skin-catalog {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-height: 70vh;
    overflow-y: auto;
}
/* Multiplayer Lobby Specifics */
#roomCodeInput { background: #1e1e1e; border: 2px solid #00ff44; color: #00ff44; padding: 10px; margin: 10px; border-radius: 8px; font-size: 16px; text-align: center; width: 200px; }
#hostSection { text-align: center; margin: 20px; }
#roomCodeDisplay { font-size: 24px; font-weight: bold; color: #00ff44; background: #000; padding: 10px; border-radius: 8px; }
/* Development Text */
.dev-text {
    position: absolute;
    bottom: 10px;
    font-size: 12px;
    opacity: 0.7;
    color: #00ff44;
    text-shadow: 0 0 3px #00ff44;
}
.dev-left { left: 10px; }
.dev-right { right: 10px; }
</style>
</head>
<body>
<!-- Canvas for Game Rendering -->
<canvas id="gameCanvas"></canvas>
<!-- Heads Up Display (HUD) -->
<div id="hud">
    <div class="topleft">
        WAVE: <span id="waveInfo">1-1</span> | HP: <span id="hp"></span> | SHIELD: <span id="shield"></span><br>
        CREDITS: <span id="credits">0</span>
    </div>
    <div class="centertop">
        <span id="stageKey">A</span> | <span id="timer">20.0</span>s
    </div>
    <div class="bottomcenter">
        Press 'R' to return to menu (or 'R' at Game Over)
    </div>
    <div class="status" id="status"></div>
</div>
<!-- Main Menu -->
<div id="menu" class="menu">
    <h1>KEYBOARD DOOM</h1>
    <p id="creditsNote" style="font-size:12px; opacity:0.7; margin-bottom:20px;">Development assisted by Grok xAI</p>
    <div id="main-menu-buttons">
        <button id="precodedBtn">World 1: Precoded (A-Z, 0-9)</button>
        <button id="precodedUniBtn">World 2: Precoded (Symbols & Unicode)</button>
        <button id="yourChoiceBtn">Checkpoints</button>
        <button id="multiplayerBtn">Multiplayer</button>
    </div>
    <!-- Shop is placed below modes -->
    <button id="skinsShopBtn">Skins Shop</button>
    <button id="backToMenuBtn" style="display:none;">Back to Main Menu</button>
    <input type="text" id="cheatInput" style="position:absolute; top:10px; right:10px; width:120px; height:30px; opacity:0.8; font-size:12px; border:1px solid #00ff44; background:rgba(0,0,0,0.7); color:#00ff44; text-align:center;" placeholder="Code..." maxlength="6">
    <div id="keypad" class="hidden"></div>
    <!-- Development Texts -->
    <div class="dev-text dev-left">Dodge and survive â€“ pure adrenaline!</div>
</div>
<!-- Skins Shop Modal -->
<div id="shop" class="shop hidden">
    <h1>Skins Shop</h1>
    <span class="text-xl mb-4 text-yellow-400">Your Credits: <span id="shopCredits">0</span></span>
    <p style="text-align:center; opacity:0.8; color:#fff; margin-bottom:10px;">Hover over icon to preview!</p>
    <div class="skin-catalog" id="skinCatalog">
        <!-- Skin cards rendered here -->
    </div>
    <button id="shopBackBtn" class="mt-4">Back to Menu</button>
    <!-- Development Texts -->
    <div class="dev-text dev-left">Dodge and survive â€“ pure adrenaline!</div>
</div>
<!-- Multiplayer Lobby -->
<div id="multiplayer-lobby" class="multiplayer-lobby hidden">
    <h1>MULTIPLAYER LOBBY</h1>
    <button id="hostGameBtn">Host Game</button>
    <div style="margin:20px;">
        <input type="text" id="roomCodeInput" placeholder="Enter 4-char code" maxlength="4">
        <button id="joinGameBtn">Join Game</button>
    </div>
    <div id="hostSection" class="hidden">
        <p>Your Room Code: <span id="roomCodeDisplay"></span></p>
        <button id="startGameBtn" class="hidden">Start Game</button>
        <div id="hostKeypad" class="hidden"></div>
    </div>
    <button id="multiBackBtn">Back to Menu</button>
    <div id="multiError" class="error-msg hidden"></div>
</div>
<!-- Game Over Screen -->
<div id="gameover" class="gameover hidden">
    <h1>GAME OVER</h1>
    <p id="finalScore" class="text-xl mb-4 text-red-500"></p>
    <p class="text-lg text-gray-300">Press 'R' to restart</p>
</div>
<!-- Victory Screen -->
<div id="victory" class="gameover hidden">
    <h1>VICTORY!</h1>
    <p id="victoryMsg" class="text-xl mb-4 text-green-500"></p>
    <p class="text-lg text-gray-300">Press 'R' to return to menu</p>
</div>
<!-- Popup for transient messages (used instead of alert) -->
<div id="popup-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100;"></div>
<script type="module">
// --- FIREBASE IMPORTS AND SETUP (For future expansion/persistence) ---
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, onSnapshot, addDoc, collection, query, where, deleteDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
const appId = typeof __app_id !== 'undefined' ? __app_id : 'keyboard-doom-v2';
let db, auth;
let userId = 'anon'; // Placeholder, will be updated by auth listener
if (firebaseConfig) {
    const app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    auth = getAuth(app);
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            userId = user.uid;
            console.log("Firebase Authenticated. User ID:", userId);
            loadProgress();
        } else {
            console.log("Firebase Not Authenticated, signing in anonymously.");
            try {
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase Auth Error:", error);
                userId = crypto.randomUUID(); // Fallback to random ID
                loadProgress();
            }
        }
                }));
} else {
    // If running outside the environment, use a fallback
    userId = 'local-user';
    console.warn("Firebase config not found. Running in local fallback mode.");
    loadProgress();
}
// --- MULTIPLAYER STATE ---
let currentRoomId = null;
let isHost = false;
let roomUnsub = null;
let roomCleanupTimer = null;
// --- CORE GAME CONSTANTS & CONFIGURATIONS ---
// World Segregation - World 1: Alphanumeric (36 stages)
const WORLD1_KEYS = [
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
];
// World 2 - Symbols, Functional Keys, and Unicodes (79+ stages)
const WORLD2_SYMBOLS = [
    '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '-', '=',
    '[', ']', '{', '}', '|', '\\', ';', ':', "'", '"', ',', '.', '<', '>', '?', '/',
    'Space', 'Enter', 'Tab', 'Shift', 'Control', 'Alt', 'CapsLock', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
];
const WORLD2_UNICODE = [
    'â†’', 'â†', 'â–²', 'â–¼', 'â˜†', 'â˜…', 'âš¡', 'âˆž', 'Ï€', 'Î©', 'Î£', 'Î¦',
    'Â§', 'Âµ', 'Â©', 'Â®', 'â„¢', 'â‚¬', 'Â£', 'Â¥', 'Â¢', 'Â°', 'Â±', 'Ã·', 'Ã—',
    'â‰ ', 'â‰ˆ', 'â‰¤', 'â‰¥', 'âˆ«', 'âˆ‚', 'âˆ‡', 'âˆš', 'âˆ›', 'âˆœ', 'â€¦', 'â€˜', 'â€™', 'â€œ', 'â€', 'Â¶'
];
const WORLD2_FULL = [...WORLD2_SYMBOLS, ...WORLD2_UNICODE];
const MAX_HP = 100;
const MAX_SHIELD = 100;
const BASE_CREDITS = 50;
const BONUS_CREDITS = 150; // Max credits per win is BASE + BONUS = 200
// --- PERIODIC TABLE DATA FOR SKIN ---
const PERIODIC_ELEMENT_DATA = [
    { num: 1, symbol: 'H', weight: 1.008, color: '#add8e6', name: 'Hydrogen' }, // Non-metal
    { num: 2, symbol: 'He', weight: 4.002, color: '#fffacd', name: 'Helium' }, // Noble gas
    { num: 6, symbol: 'C', weight: 12.011, color: '#3cb371', name: 'Carbon' }, // Non-metal
    { num: 8, symbol: 'O', weight: 15.999, color: '#f08080', name: 'Oxygen' }, // Non-metal
    { num: 11, symbol: 'Na', weight: 22.990, color: '#8a2be2', name: 'Sodium' }, // Alkali metal
    { num: 17, symbol: 'Cl', weight: 35.453, color: '#90ee90', name: 'Chlorine' }, // Halogen
    { num: 19, symbol: 'K', weight: 39.098, color: '#9370db', name: 'Potassium' }, // Alkali metal
    { num: 26, symbol: 'Fe', weight: 55.845, color: '#bdb76b', name: 'Iron' }, // Transition metal
    { num: 29, symbol: 'Cu', weight: 63.546, color: '#b8860b', name: 'Copper' }, // Transition metal
    { num: 47, symbol: 'Ag', weight: 107.87, color: '#c0c0c0', name: 'Silver' }, // Transition metal
    { num: 79, symbol: 'Au', weight: 196.97, color: '#ffd700', name: 'Gold' }, // Transition metal
    { num: 80, symbol: 'Hg', weight: 200.59, color: '#cccccc', name: 'Mercury' }, // Transition metal
];
function getRandomPeriodicElement() {
    return PERIODIC_ELEMENT_DATA[Math.floor(Math.random() * PERIODIC_ELEMENT_DATA.length)];
}
// --- GAME STATE AND PROGRESS OBJECTS ---
const player = {
    x: 0, y: 0, radius: 10, speed: 4,
    hp: MAX_HP, maxHp: MAX_HP, shield: 0,
    dead: false,
    credits: 0,
    equippedSkinId: 'default',
    skinState: { // For dynamic skins
        catNextChangeTime: 0,
        catFace: 'owo',
        periodicElement: PERIODIC_ELEMENT_DATA[0] // Initialize with H
    }
};
const game = {
    mode: 'menu', // 'menu', 'precoded', 'precoded-uni', 'playing', 'checkpoints', 'multi'
    world: 'world1', // 'world1', 'world2'
    stageIndex: 0,
    stageKey: 'A',
    timer: 0,
    score: 0,
    attacks: [],
    diggers: [],
    shake: 0,
    lastTime: 0,
    lastDamageTime: 0,
    winning: false, // Flag to prevent multiple gameWin calls
    animationFrameId: null // To store the ID of requestAnimationFrame
};
let progress = {
    world1: false, // World completion flag
    world2: false, // World completion flag
    // Unlocked keys now include 'd', 'e', and 'f' for testing the new attacks
    unlockedKeys: ['a', 'b', 'c', 'd', 'e', 'f', 'g', '0', 'Space'],
    ownedSkins: ['default'],
    equippedSkinId: 'default',
    credits: 0
};
let previewStates = {}; // For skin preview animations
// --- DOM ELEMENTS ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const hud = document.getElementById('hud');
const menu = document.getElementById('menu');
const gameover = document.getElementById('gameover');
const victory = document.getElementById('victory');
const shop = document.getElementById('shop');
const multiplayerLobby = document.getElementById('multiplayer-lobby');
const keypad = document.getElementById('keypad');
const hostKeypad = document.getElementById('hostKeypad');
const precodedBtn = document.getElementById('precodedBtn');
const precodedUniBtn = document.getElementById('precodedUniBtn');
const yourChoiceBtn = document.getElementById('yourChoiceBtn');
const multiplayerBtn = document.getElementById('multiplayerBtn');
const skinsShopBtn = document.getElementById('skinsShopBtn');
const shopBackBtn = document.getElementById('shopBackBtn');
const backToMenuBtn = document.getElementById('backToMenuBtn');
const cheatInput = document.getElementById('cheatInput');
const hostGameBtn = document.getElementById('hostGameBtn');
const joinGameBtn = document.getElementById('joinGameBtn');
const multiBackBtn = document.getElementById('multiBackBtn');
const roomCodeInput = document.getElementById('roomCodeInput');
const roomCodeDisplay = document.getElementById('roomCodeDisplay');
const startGameBtn = document.getElementById('startGameBtn');
const hostSection = document.getElementById('hostSection');
const multiError = document.getElementById('multiError');
// --- FIREBASE PERSISTENCE FUNCTIONS ---
function getProgressRef() {
    return doc(db, "artifacts", appId, "users", userId, "progress", "state");
}
async function saveProgress() {
    if (db && userId) {
        progress.equippedSkinId = player.equippedSkinId; // Save equipped skin
        progress.unlockedKeys = Array.from(new Set(progress.unlockedKeys)); // Ensure unique keys
        progress.credits = player.credits; // Ensure credits are saved
        try {
            await setDoc(getProgressRef(), progress);
        } catch(e) {
            console.error("Error saving progress:", e);
        }
    } else {
        localStorage.setItem(appId + '_progress', JSON.stringify(progress));
        localStorage.setItem(appId + '_credits', player.credits.toString());
        localStorage.setItem(appId + '_equippedSkin', player.equippedSkinId);
    }
}
async function loadProgress() {
    // Attempt to load from Firestore first
    if (db && userId) {
        try {
            const docSnap = await getDoc(getProgressRef());
            if (docSnap.exists()) {
                progress = docSnap.data();
                player.equippedSkinId = progress.equippedSkinId || 'default';
                player.credits = progress.credits || 0;
            } else {
                console.log("No progress found, initializing new state.");
                progress.credits = player.credits;
                await saveProgress();
            }
        } catch (e) {
            console.error("Error loading progress, falling back to local storage:", e);
            loadProgressLocal();
        }
    } else {
        loadProgressLocal();
    }
    updateHUD();
}
function loadProgressLocal() {
    const localProgress = localStorage.getItem(appId + '_progress');
    const localCredits = localStorage.getItem(appId + '_credits');
    const localSkin = localStorage.getItem(appId + '_equippedSkin');
    if (localProgress) {
        progress = JSON.parse(localProgress);
    }
    if (localCredits) {
        player.credits = parseInt(localCredits);
    }
    if (localSkin) {
        player.equippedSkinId = localSkin;
    }
}
// --- MULTIPLAYER FUNCTIONS ---
async function showMultiplayerLobby() {
    menu.classList.add('hidden');
    multiplayerLobby.classList.remove('hidden');
    hostSection.classList.add('hidden');
    multiError.classList.add('hidden');
    roomCodeInput.value = '';
}
async function hostGame() {
    if (!db) {
        showMultiError('Firebase unavailable. Multiplayer fallback to local (solo mode).');
        return;
    }
    try {
        const roomCode = Math.random().toString(36).substr(2,4).toUpperCase();
        const roomsCol = collection(db, 'rooms');
        const roomRef = await addDoc(roomsCol, {
            code: roomCode,
            hostId: userId,
            players: [userId],
            stageKey: null,
            world: null,
            started: false,
            createdAt: Date.now(),
            lastActive: Date.now()
        });
        currentRoomId = roomRef.id;
        isHost = true;
        roomCodeDisplay.textContent = roomCode;
        hostSection.classList.remove('hidden');
        roomUnsub = onSnapshot(doc(db, 'rooms', currentRoomId), (snap) => {
            if (!snap.exists()) {
                cleanupRoom();
                showMultiError('Room expired.');
                return;
            }
            const data = snap.data();
            if (data.players.length > 4) {
                showMultiError('Room full.');
                return;
            }
            game.stageKey = data.stageKey;
            game.world = data.world;
            if (data.started) {
                startGame('multi', data.world, data.stageKey);
                cleanupRoom(); // Cleanup after start
            }
            updateActive(data.lastActive);
        });
        // Cleanup timer
        roomCleanupTimer = setTimeout(() => deleteRoom(currentRoomId), 300000); // 5 min
        buildHostKeypad();
    } catch (e) {
        console.error('Host error:', e);
        showMultiError('Failed to create room. Falling back to local.');
        // TODO: Implement WebRTC fallback for P2P hosting
    }
}
async function joinGame() {
    const code = roomCodeInput.value.toUpperCase().trim();
    if (!code || code.length !== 4 || !db) {
        showMultiError('Invalid code or Firebase unavailable. Try hosting.');
        return;
    }
    try {
        const roomsCol = collection(db, 'rooms');
        const q = query(roomsCol, where('code', '==', code));
        roomUnsub = onSnapshot(q, (snap) => {
            if (snap.empty) {
                showMultiError('Room not found.');
                return;
            }
            const roomDoc = snap.docs[0];
            const data = roomDoc.data();
            if (data.players.length >= 4) {
                showMultiError('Room full.');
                return;
            }
            if (!data.players.includes(userId)) {
                updateDoc(doc(db, 'rooms', roomDoc.id), {
                    players: [...data.players, userId],
                    lastActive: Date.now()
                });
            }
            currentRoomId = roomDoc.id;
            isHost = false;
            hostSection.classList.add('hidden'); // Hide host UI for joiner
            startGameBtn.style.display = 'none';
            hostKeypad.classList.add('hidden');
            roomCodeDisplay.textContent = code;
            hostSection.classList.remove('hidden'); // Show code for confirmation
            // Listen for changes
            const roomListener = onSnapshot(doc(db, 'rooms', currentRoomId), (rsnap) => {
                if (!rsnap.exists()) {
                    cleanupRoom();
                    showMultiError('Room expired.');
                    return;
                }
                const rdata = rsnap.data();
                game.stageKey = rdata.stageKey;
                game.world = rdata.world;
                if (rdata.started) {
                    startGame('multi', rdata.world, rdata.stageKey);
                    roomListener();
                    cleanupRoom();
                }
                updateActive(rdata.lastActive);
            });
        });
    } catch (e) {
        console.error('Join error:', e);
        showMultiError('Failed to join. Falling back to local.');
        // TODO: Implement WebRTC fallback for P2P joining (auto-discover via WiFi? Requires signaling)
    }
}
function buildHostKeypad() {
    hostKeypad.innerHTML = '';
    const worldKeys = [...WORLD1_KEYS, ...WORLD2_FULL];
    worldKeys.forEach(k => {
        const keybtn = document.createElement('div');
        keybtn.className = 'key-btn';
        keybtn.textContent = progress.unlockedKeys.includes(k) ? k.toUpperCase() : '?';
        const isUnlocked = progress.unlockedKeys.includes(k);
        if (!isUnlocked) {
            keybtn.classList.add('locked');
        } else {
            keybtn.onclick = async () => {
                let world = WORLD1_KEYS.includes(k) ? 'world1' : 'world2';
                if (db && currentRoomId && isHost) {
                    try {
                        await updateDoc(doc(db, 'rooms', currentRoomId), {
                            stageKey: k,
                            world: world,
                            lastActive: Date.now()
                        });
                        hostKeypad.classList.add('hidden');
                        startGameBtn.classList.remove('hidden');
                    } catch (e) {
                        console.error('Update stage error:', e);
                    }
                }
            };
        }
        hostKeypad.appendChild(keybtn);
    });
    hostKeypad.classList.remove('hidden');
}
async function startMultiGame() {
    if (isHost && db && currentRoomId) {
        try {
            await updateDoc(doc(db, 'rooms', currentRoomId), { started: true, lastActive: Date.now() });
        } catch (e) {
            console.error('Start game error:', e);
        }
    }
}
function updateActive(lastActive) {
    if (roomCleanupTimer) clearTimeout(roomCleanupTimer);
    roomCleanupTimer = setTimeout(() => deleteRoom(currentRoomId), 300000);
}
async function deleteRoom(roomId) {
    if (db && roomId) {
        try {
            await deleteDoc(doc(db, 'rooms', roomId));
        } catch (e) {
            console.error('Delete room error:', e);
        }
    }
    cleanupRoom();
}
function cleanupRoom() {
    if (roomUnsub) roomUnsub();
    roomUnsub = null;
    currentRoomId = null;
    isHost = false;
    if (roomCleanupTimer) clearTimeout(roomCleanupTimer);
    roomCleanupTimer = null;
}
function showMultiError(msg) {
    multiError.textContent = msg;
    multiError.classList.remove('hidden');
    setTimeout(() => multiError.classList.add('hidden'), 3000);
}
// --- UTILITY AND DRAWING FUNCTIONS ---
function showPopup(text, x, y, duration, color = '#fff') {
    const container = document.getElementById('popup-container');
    const popup = document.createElement('div');
    popup.style.cssText = `
        position: absolute;
        left: ${x}px;
        top: ${y}px;
        transform: translate(-50%, -50%);
        padding: 5px 10px;
        background: ${color};
        color: #000;
        border-radius: 5px;
        font-size: 16px;
        font-weight: bold;
        opacity: 1;
        transition: all 0.5s ease-out;
        pointer-events: none;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
    `;
    popup.textContent = text;
    container.appendChild(popup);
    setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.top = (y - 50) + 'px';
        setTimeout(() => popup.remove(), 500);
    }, duration);
}
function updateHUD() {
    const keyset = game.world === 'world1' ? WORLD1_KEYS : WORLD2_FULL;
    const waveNumber = game.stageIndex + 1;
    const totalWaves = keyset.length;
    let worldDisplay = '';
    if (game.world === 'world1') worldDisplay = '1';
    else if (game.world === 'world2') worldDisplay = '2';
    else if (game.mode === 'playing') worldDisplay = 'CP'; // Checkpoints Mode
    document.getElementById('waveInfo').textContent = `${worldDisplay}-${waveNumber} / ${totalWaves}`;
    document.getElementById('hp').textContent = Math.ceil(player.hp);
    document.getElementById('shield').textContent = Math.ceil(player.shield);
    document.getElementById('credits').textContent = player.credits;
    document.getElementById('stageKey').textContent = game.stageKey.toUpperCase(); // Show key in caps
    document.getElementById('timer').textContent = game.timer.toFixed(1);
    document.getElementById('shopCredits').textContent = player.credits; // Update shop display
}
function startShake(duration, intensity) {
    game.shake = intensity;
    setTimeout(() => game.shake = 0, duration);
}
// --- PLAYER AND SKIN LOGIC ---
// Skin Catalog (Removed crystal_facet - FIXED: Remove redundant skin)
const SKIN_CATALOG = [
    { id: 'default', name: 'Base Dodecahedron', type: 'Static Glyph', price: 0, desc: 'The reliable geometry that protects you. Simple, robust, boring.', preview: 'â—', color: '#00ff44' },
    { id: 'retro_term', name: 'Vintage Terminal', type: 'Pixel/Trail Effect', price: 800, desc: 'Renders the player as a flashing green cursor block, leaving behind a brief ghost trail of \'console output\' text.', preview: 'â–ˆ', color: '#00ff00' },
    { id: 'star_map', name: 'Cosmic Starmap', type: 'Particle Cluster', price: 1800, desc: 'A swirling constellation of tiny stars that react to your movement.', preview: 'âœ¨', color: '#ffffff' },
    { id: 'cat_txt', name: 'cat.txt', type: 'Animated Text', price: 1500, desc: 'A glitching, animated text box that communicates its status via classic emoticon faces (owo, -w-, ;w;).', preview: 'owo', color: '#ffb300' },
    { id: 'shards', name: 'Flickering Shards', type: 'Dynamic Geometry', price: 2500, desc: 'The player breaks into small, flickering geometric shards when hit, unifying on recovery.', preview: 'â¬¢', color: '#ff00ff' },
    { id: 'periodic', name: 'Periodic Table', type: 'Styled Box/Text', price: 2200, desc: 'Transforms into a color-coded element block, showing atomic data.', preview: 'Au', color: '#00ffff' },
    { id: 'dino_mode', name: 'Dinosaur Mode', type: 'Emoji', price: 500, desc: 'Transforms you into a majestic, low-cost dinosaur icon.', preview: 'ðŸ¦–', color: '#00cc00' },
    { id: 'hex_burst', name: 'Hex Code Burst', type: 'Dynamic Geometry', price: 3500, desc: 'The player is drawn as a cluster of constantly changing 6-digit hexadecimal color codes (based on player HP/shield status).', preview: '#A3FF4B', color: '#ff00ff' },
    { id: 'neon_glow', name: 'Neon Glow', type: 'Glowing Outline', price: 1200, desc: 'A pulsating neon outline that leaves a faint glow trail effect.', preview: 'âŸ¡', color: '#ff00ff' },
    { id: 'glitch', name: 'Glitch Effect', type: 'Distorted Render', price: 1600, desc: 'Player render with RGB split and scanline distortion.', preview: 'â–ˆ', color: '#ff0000' },
    { id: 'matrix_code', name: 'Matrix Code', type: 'Falling Code', price: 2000, desc: 'Surrounded by orbiting binary code digits.', preview: '01', color: '#00ff00' },
    { id: 'plasma_orbs', name: 'Plasma Orbs', type: 'Orbital Particles', price: 2800, desc: 'Multiple plasma orbs orbiting the core with electric arcs.', preview: 'âš¡', color: '#ff1493' },
    { id: 'cyber_grid', name: 'Cyber Grid', type: 'Wireframe', price: 900, desc: 'A holographic wireframe grid that rotates and pulses.', preview: 'â–±', color: '#00ffff' },
    { id: 'firefly_swarm', name: 'Firefly Swarm', type: 'Swarming Lights', price: 1900, desc: 'A swarm of tiny fireflies that flicker and follow movement patterns.', preview: 'ðŸª°', color: '#ffff00' },
    { id: 'void_portal', name: 'Void Portal', type: 'Swirling Vortex', price: 3200, desc: 'A dark portal that sucks in light and emits shadowy tendrils.', preview: 'ðŸŒ€', color: '#4b0082' },
    { id: 'sunflare', name: 'Sunflare', type: 'Radiant Burst', price: 1400, desc: 'Solar flare effects with coronal mass ejections.', preview: 'â˜€ï¸', color: '#ffd700' },
    { id: 'ice_crystal', name: 'Ice Crystal', type: 'Fractal Snow', price: 1100, desc: 'Growing ice fractals that shimmer with frost.', preview: 'â„ï¸', color: '#add8e6' },
    { id: 'lava_flow', name: 'Lava Flow', type: 'Molten', price: 2300, desc: 'Slow-flowing lava with bubbling embers.', preview: 'ðŸŒ‹', color: '#ff4500' },
    { id: 'neural_net', name: 'Neural Net', type: 'Synaptic', price: 3000, desc: 'Interconnected neural nodes firing signals.', preview: 'ðŸ§ ', color: '#9370db' },
    { id: 'quantum_flux', name: 'Quantum Flux', type: 'Waveform Interference', price: 3800, desc: 'Overlapping quantum waves that interfere and create probabilistic patterns.', preview: 'âŸ', color: '#8a2be2' },
    { id: 'arcade_pixel', name: 'Arcade Pixel', type: 'Retro Sprite', price: 600, desc: '8-bit pixel art sprite with dithering and scanlines.', preview: 'â¬œ', color: '#ff69b4' },
    { id: 'steampunk_gear', name: 'Steampunk Gear', type: 'Mechanical', price: 1700, desc: 'Brass gears and pistons with steam exhaust effects.', preview: 'âš™ï¸', color: '#cd7f32' },
    { id: 'bioluminescent', name: 'Bioluminescent', type: 'Organic Glow', price: 2100, desc: 'Glowing jellyfish-like tendrils that pulse with bioluminescence.', preview: 'ðŸŒŠ', color: '#00ced1' },
    { id: 'holo_cube', name: 'Holo Cube', type: '3D Projection', price: 2900, desc: 'Rotating holographic cube with wireframe edges.', preview: 'â¬ž', color: '#87ceeb' },
    { id: 'shadow_puppeteer', name: 'Shadow Puppeteer', type: 'Silhouette', price: 1300, desc: 'Dynamic shadow puppet that morphs shapes.', preview: 'ðŸ–¤', color: '#000000' },
    { id: 'electric_arc', name: 'Electric Arc', type: 'Lightning', price: 2400, desc: 'Crackling electric arcs that chain between nodes.', preview: 'âš¡', color: '#ffff00' },
    { id: 'flame_wisp', name: 'Flame Wisp', type: 'Ethereal Fire', price: 1500, desc: 'Floating flame wisps that trail embers.', preview: 'ðŸ”¥', color: '#ff4500' },
    { id: 'thorn_vine', name: 'Thorn Vine', type: 'Organic Growth', price: 1800, desc: 'Twisting thorn vines that grow and retract.', preview: 'ðŸŒ¿', color: '#228b22' },
    { id: 'echo_waveform', name: 'Echo Waveform', type: 'Audio Visualizer', price: 2700, desc: 'Oscillating waveforms that echo with sound-like pulses.', preview: 'âˆ¿', color: '#ff1493' },
    { id: 'grok_xai', name: 'GROK x.AI', type: 'Animated Black Hole', price: 0, desc: 'A swirling black hole with orbiting particles, crafted with assistance from Grok xAI.', preview: 'ðŸ•³ï¸', color: '#ffffff' }
];
function drawSkin(drawCtx, x, y, radius, skinId, skinState, hp, maxHp, lastDamageTime) {
    const skin = SKIN_CATALOG.find(s => s.id === skinId);
    if (!skin) return;
    const time = Date.now();
    const pulse = 1 + Math.sin(time / 800) * 0.1;
    const isDamaged = hp < maxHp * 0.5 || (lastDamageTime && time - lastDamageTime < 700);
    drawCtx.save();
    drawCtx.translate(x, y);
    drawCtx.fillStyle = skin.color;
    drawCtx.strokeStyle = '#fff';
    drawCtx.lineWidth = 2;
    switch (skinId) {
        case 'default':
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.stroke();
            break;
        case 'cat_txt':
            const catFace = skinState ? skinState.catFace : 'owo';
            drawCtx.font = 'bold 24px Inter';
            drawCtx.textAlign = 'center';
            drawCtx.fillText(catFace, 0, 8);
            drawCtx.strokeText(catFace, 0, 8);
            break;
        case 'periodic':
            const element = skinState && skinState.periodicElement || getRandomPeriodicElement();
            const elementSize = 30 * pulse;
            const elementBorderColor = '#333';
     
            drawCtx.save();
            drawCtx.scale(pulse, pulse);
            drawCtx.translate(-elementSize / (2 * pulse), -elementSize / (2 * pulse)); // Adjust for scale
     
            // 1. Draw Element Background and Border
            drawCtx.fillStyle = element.color || '#cccccc';
            drawCtx.fillRect(0, 0, elementSize / pulse, elementSize / pulse);
     
            drawCtx.strokeStyle = elementBorderColor;
            drawCtx.lineWidth = 1.5;
            drawCtx.strokeRect(0, 0, elementSize / pulse, elementSize / pulse);
     
            // 2. Draw Atomic Number (Top Left)
            drawCtx.font = `${7 * pulse}px Inter`;
            drawCtx.fillStyle = elementBorderColor;
            drawCtx.textAlign = 'left';
            drawCtx.fillText(element.num.toString(), 2, 8);
     
            // 3. Draw Symbol (Center)
            drawCtx.font = `bold ${15 * pulse}px Inter`;
            drawCtx.fillStyle = elementBorderColor;
            drawCtx.textAlign = 'center';
            drawCtx.fillText(element.symbol, (elementSize / (2 * pulse)), (elementSize / (2 * pulse)) + 5);
     
            // 4. Draw Atomic Weight (Bottom Center)
            drawCtx.font = `${6 * pulse}px Inter`;
            drawCtx.fillStyle = elementBorderColor;
            drawCtx.textAlign = 'center';
            drawCtx.fillText(element.weight.toFixed(3), (elementSize / (2 * pulse)), elementSize / pulse - 3);
            drawCtx.restore();
            break;
     
        case 'dino_mode':
            drawCtx.font = 'bold 24px Inter';
            drawCtx.textAlign = 'center';
            drawCtx.fillText('ðŸ¦–', 0, 8);
            break;
        case 'retro_term':
            drawCtx.fillRect(-radius, -radius, radius * 2, radius * 2);
            // Simple flashing effect
            if (Math.floor(time / 200) % 2 === 0) {
                drawCtx.strokeStyle = '#000';
                drawCtx.strokeRect(-radius, -radius, radius * 2, radius * 2);
            }
            break;
     
        case 'shards':
            if (isDamaged) {
                // Flicker and draw as small scattered triangles
                if (Math.floor(time / 50) % 2 === 0) {
                    drawCtx.globalAlpha = 0.6;
                }
                for(let i=0; i<5; i++) {
                    const angle = i * Math.PI / 2.5;
                    drawCtx.save();
                    drawCtx.rotate(angle);
                    drawCtx.translate(Math.random()*4 - 2, Math.random()*4 - 2);
                    drawCtx.beginPath();
                    drawCtx.moveTo(radius, 0);
                    drawCtx.lineTo(radius * -0.5, radius * 0.866);
                    drawCtx.lineTo(radius * -0.5, radius * -0.866);
                    drawCtx.closePath();
                    drawCtx.fill();
                    drawCtx.stroke();
                    drawCtx.restore();
                }
                drawCtx.globalAlpha = 1;
            } else {
                // Draw as a solid hexagon when healthy
                drawCtx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    const px = radius * Math.cos(angle);
                    const py = radius * Math.sin(angle);
                    if (i === 0) drawCtx.moveTo(px, py);
                    else drawCtx.lineTo(px, py);
                }
                drawCtx.closePath();
                drawCtx.fill();
                drawCtx.stroke();
            }
            break;
     
        case 'star_map':
            const starCount = 20;
            drawCtx.globalAlpha = 0.8;
            for (let i = 0; i < starCount; i++) {
                // Simple sine-wave movement for twinkling/swirling
                const angle = (i * 0.3) + (time * 0.001);
                const r = radius * 0.8 + Math.sin(time * 0.005 + i) * 2;
                const starSize = 1 + Math.random() * 1.5;
                drawCtx.fillRect(Math.cos(angle) * r, Math.sin(angle) * r, starSize, starSize);
            }
            drawCtx.globalAlpha = 1;
            break;
        case 'hex_burst':
            const baseColor = (hp > 50) ? '#00FF00' : (hp > 20 ? '#FFFF00' : '#FF0000');
            const hexPulse = Math.sin(time / 300) * 0.3 + 0.7;
            drawCtx.fillStyle = baseColor;
            drawCtx.globalAlpha = hexPulse;
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius * 0.7 * hexPulse, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.globalAlpha = 1;
            // Draw more hex codes, rotating and pulsing
            for(let i=0; i<12; i++) { // More codes
                const angle = i * Math.PI / 6 + time * 0.002; // Faster rotation
                const offset = radius * (1.5 + Math.sin(time / 500 + i) * 0.5); // Pulsing offset
                const hexCode = Math.floor(Math.random()*16777215).toString(16).padStart(6, '0').toUpperCase();
                const size = 6 + Math.sin(time / 200 + i) * 2; // Pulsing size
                drawCtx.font = `${size}px Inter`;
                drawCtx.fillStyle = `hsl(${ (time / 100) % 360 }, 100%, 50%)`; // Rainbow colors
                drawCtx.textAlign = 'center';
                drawCtx.textBaseline = 'middle';
                drawCtx.fillText('#' + hexCode, Math.cos(angle) * offset, Math.sin(angle) * offset);
            }
            // Add trail effect
            drawCtx.globalAlpha = 0.3;
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius * 1.2, 0, Math.PI * 2);
            drawCtx.strokeStyle = baseColor;
            drawCtx.lineWidth = 2;
            drawCtx.stroke();
            drawCtx.globalAlpha = 1;
            break;
        case 'neon_glow':
            drawCtx.shadowColor = skin.color;
            drawCtx.shadowBlur = 20 + Math.sin(time / 200) * 5;
            drawCtx.strokeStyle = skin.color;
            drawCtx.lineWidth = 3;
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.stroke();
            drawCtx.shadowBlur = 0;
            break;
        case 'glitch':
            // RGB split effect with animation
            const glitchOffset = Math.sin(time / 300) * 2;
            // Red
            drawCtx.save();
            drawCtx.translate(glitchOffset, 0);
            drawCtx.fillStyle = '#f00';
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.restore();
            // Blue
            drawCtx.save();
            drawCtx.translate(-glitchOffset, Math.sin(time / 400));
            drawCtx.fillStyle = '#00f';
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.restore();
            // Green
            drawCtx.fillStyle = '#0f0';
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.fill();
            break;
        case 'matrix_code':
            // Orbiting binary digits
            drawCtx.fillStyle = '#000';
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius * 0.8, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.fillStyle = skin.color;
            drawCtx.font = '10px monospace';
            drawCtx.textAlign = 'center';
            drawCtx.textBaseline = 'middle';
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI / 4) + (time * 0.002);
                const r = radius + 10 + i * 3;
                const char = Math.random() > 0.5 ? '0' : '1';
                drawCtx.fillText(char, Math.cos(angle) * r, Math.sin(angle) * r);
            }
            break;
        case 'plasma_orbs':
            // Orbiting orbs with arcs
            for (let i = 0; i < 3; i++) {
                const angle = (i * Math.PI * 2 / 3) + (time * 0.003);
                const r = radius + 15;
                drawCtx.beginPath();
                drawCtx.arc(Math.cos(angle) * r, Math.sin(angle) * r, 4, 0, Math.PI * 2);
                drawCtx.fill();
                // Arc to center
                drawCtx.strokeStyle = skin.color;
                drawCtx.lineWidth = 1;
                drawCtx.beginPath();
                drawCtx.moveTo(0, 0);
                drawCtx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                drawCtx.stroke();
            }
            break;
        case 'cyber_grid':
            // Rotating wireframe
            drawCtx.save();
            drawCtx.rotate(time * 0.001);
            drawCtx.strokeStyle = skin.color;
            drawCtx.lineWidth = 1;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    drawCtx.beginPath();
                    drawCtx.moveTo(i * radius, j * radius);
                    drawCtx.lineTo(0, 0);
                    drawCtx.stroke();
                }
            }
            drawCtx.restore();
            break;
        case 'firefly_swarm':
            // Flickering dots
            drawCtx.globalAlpha = 0.7;
            for (let i = 0; i < 15; i++) {
                const angle = i * 0.4 + time * 0.004;
                const r = radius * 0.5 + Math.sin(time * 0.01 + i) * 5;
                const alpha = 0.5 + Math.sin(time * 0.02 + i) * 0.5;
                drawCtx.globalAlpha = alpha;
                drawCtx.fillRect(Math.cos(angle) * r, Math.sin(angle) * r, 2, 2);
            }
            drawCtx.globalAlpha = 1;
            break;
        case 'void_portal':
            // Swirling darkness with pulse and idle tendrils
            drawCtx.save();
            drawCtx.scale(pulse, pulse);
            const gradient = drawCtx.createRadialGradient(0, 0, 0, 0, 0, radius * 2 / pulse);
            gradient.addColorStop(0, '#000');
            gradient.addColorStop(1, skin.color);
            drawCtx.fillStyle = gradient;
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius * 2 / pulse, 0, Math.PI * 2);
            drawCtx.fill();
            // Add swirling tendrils
            for (let i = 0; i < 8; i++) {
                const angle = i * Math.PI / 4 + time * 0.01;
                const r = radius * 0.5 / pulse;
                drawCtx.strokeStyle = '#fff';
                drawCtx.lineWidth = 1;
                drawCtx.globalAlpha = 0.3 + Math.sin(time * 0.02 + i) * 0.2;
                drawCtx.beginPath();
                drawCtx.moveTo(0, 0);
                drawCtx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                drawCtx.stroke();
            }
            drawCtx.globalAlpha = 1;
            drawCtx.restore();
            break;
        case 'sunflare':
            // Radiant rays
            drawCtx.fillStyle = '#fff';
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius * 0.5, 0, Math.PI * 2);
            drawCtx.fill();
            for (let i = 0; i < 8; i++) {
                const angle = i * Math.PI / 4 + time * 0.005;
                drawCtx.strokeStyle = skin.color;
                drawCtx.lineWidth = 2;
                drawCtx.beginPath();
                drawCtx.moveTo(0, 0);
                drawCtx.lineTo(Math.cos(angle) * radius * 2, Math.sin(angle) * radius * 2);
                drawCtx.stroke();
            }
            break;
        case 'ice_crystal':
            // Fractal lines
            drawCtx.strokeStyle = skin.color;
            drawCtx.lineWidth = 2;
            function drawBranch(len, angle) {
                if (len < 2) return;
                drawCtx.beginPath();
                drawCtx.moveTo(0, 0);
                drawCtx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
                drawCtx.stroke();
                drawBranch(len * 0.7, angle + 0.3);
                drawBranch(len * 0.7, angle - 0.3);
            }
            drawBranch(radius, 0);
            break;
        case 'lava_flow':
            // Bubbling blobs
            drawCtx.fillStyle = skin.color;
            for (let i = 0; i < 4; i++) {
                const px = Math.sin(time * 0.003 + i) * 3;
                const py = Math.cos(time * 0.002 + i) * 3;
                drawCtx.beginPath();
                drawCtx.arc(px, py, radius * 0.6, 0, Math.PI * 2);
                drawCtx.fill();
            }
            // Embers
            drawCtx.fillStyle = '#fff';
            for (let i = 0; i < 5; i++) {
                drawCtx.fillRect(Math.random() * radius * 2 - radius, Math.random() * radius * 2 - radius, 1, 1);
            }
            break;
        case 'neural_net':
            // Connected nodes with pulse and firing signals
            drawCtx.save();
            drawCtx.scale(pulse, pulse);
            drawCtx.fillStyle = '#000';
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius / pulse, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.fillStyle = skin.color;
            const nodes = [];
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3;
                const r = (radius * 0.5) / pulse;
                const nx = Math.cos(angle) * r;
                const ny = Math.sin(angle) * r;
                nodes.push({x: nx, y: ny});
                // Pulsing nodes
                const nodeAlpha = 0.5 + Math.sin(time * 0.01 + i) * 0.5;
                drawCtx.globalAlpha = nodeAlpha;
                drawCtx.beginPath();
                drawCtx.arc(nx, ny, 3, 0, Math.PI * 2);
                drawCtx.fill();
                // Firing signals: random connections
                if (Math.random() > 0.7) {
                    const target = nodes[(i + 1 + Math.floor(Math.random() * 3)) % 6];
                    drawCtx.strokeStyle = skin.color;
                    drawCtx.lineWidth = 1;
                    drawCtx.globalAlpha = nodeAlpha * 0.5;
                    drawCtx.beginPath();
                    drawCtx.moveTo(0, 0);
                    drawCtx.lineTo(target.x, target.y);
                    drawCtx.stroke();
                }
                drawCtx.globalAlpha = 1;
            }
            drawCtx.restore();
            break;
        case 'quantum_flux':
            // Wave interference
            drawCtx.strokeStyle = skin.color;
            drawCtx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const offset = i * 10 + time * 0.01;
                drawCtx.beginPath();
                for (let j = 0; j < 360; j += 5) {
                    const rad = j * Math.PI / 180;
                    const wave = Math.sin(rad + offset) * 5;
                    const px = Math.cos(rad) * (radius + wave);
                    const py = Math.sin(rad) * (radius + wave);
                    if (j === 0) drawCtx.moveTo(px, py);
                    else drawCtx.lineTo(px, py);
                }
                drawCtx.closePath();
                drawCtx.stroke();
            }
            break;
        case 'arcade_pixel':
            // Pixelated sprite
            drawCtx.imageSmoothingEnabled = false;
            drawCtx.fillStyle = skin.color;
            for (let px = -radius; px < radius; px += 4) {
                for (let py = -radius; py < radius; py += 4) {
                    if (Math.random() > 0.5) drawCtx.fillRect(px, py, 4, 4);
                }
            }
            // Scanlines
            drawCtx.strokeStyle = '#000';
            drawCtx.lineWidth = 1;
            for (let i = 0; i < radius * 2; i += 2) {
                drawCtx.beginPath();
                drawCtx.moveTo(-radius, i - radius);
                drawCtx.lineTo(radius, i - radius);
                drawCtx.stroke();
            }
            break;
        case 'steampunk_gear':
            // Gears with steam particles
            drawCtx.fillStyle = '#cd7f32';
            drawCtx.beginPath();
            for (let i = 0; i < 12; i++) {
                const angle = i * Math.PI / 6;
                drawCtx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
            drawCtx.closePath();
            drawCtx.fill();
            // Rotate
            drawCtx.save();
            drawCtx.rotate(time * 0.005);
            drawCtx.strokeStyle = '#8b4513';
            drawCtx.lineWidth = 2;
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.stroke();
            drawCtx.restore();
            // Add steam particles
            for (let p = 0; p < 5; p++) {
                const px = Math.cos(time * 0.01 + p * 1.5) * (radius + 10);
                const py = Math.sin(time * 0.01 + p * 1.5) * (radius + 10);
                const steamAlpha = 0.3 + Math.sin(time * 0.02 + p) * 0.2;
                drawCtx.fillStyle = `rgba(255,255,255,${steamAlpha})`;
                drawCtx.beginPath();
                drawCtx.arc(px, py, 2 + Math.sin(time * 0.015 + p) * 1, 0, Math.PI * 2);
                drawCtx.fill();
            }
            break;
        case 'bioluminescent':
            // Pulsing tendrils
            for (let i = 0; i < 8; i++) {
                const angle = i * Math.PI / 4 + Math.sin(time * 0.005) * 0.1;
                const len = radius + Math.sin(time * 0.01 + i) * 10;
                drawCtx.strokeStyle = skin.color;
                drawCtx.lineWidth = 2;
                drawCtx.globalAlpha = 0.8 + Math.sin(time * 0.02 + i) * 0.2;
                drawCtx.beginPath();
                drawCtx.moveTo(0, 0);
                drawCtx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
                drawCtx.stroke();
            }
            drawCtx.globalAlpha = 1;
            break;
        case 'holo_cube':
            // 3D cube projection
            drawCtx.strokeStyle = skin.color;
            drawCtx.lineWidth = 2;
            const rotX = time * 0.001;
            const rotY = time * 0.002;
            const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
            const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
            const verts = [
                [-10, -10, -10], [10, -10, -10], [10, 10, -10], [-10, 10, -10],
                [-10, -10, 10], [10, -10, 10], [10, 10, 10], [-10, 10, 10]
            ].map(v => ({
                x: v[0] * cosY - v[2] * sinY,
                y: (v[1] * cosX - v[2] * sinX) * 20,
                z: v[0] * sinY + v[2] * cosY
            }));
            // Draw edges (simplified)
            const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
            edges.forEach(e => {
                drawCtx.beginPath();
                drawCtx.moveTo(verts[e[0]].x + radius / 2, verts[e[0]].y + radius / 2);
                drawCtx.lineTo(verts[e[1]].x + radius / 2, verts[e[1]].y + radius / 2);
                drawCtx.stroke();
            });
            break;
        case 'shadow_puppeteer':
            // Morphing shadow
            const morph = Math.sin(time / 1000);
            drawCtx.fillStyle = '#000';
            drawCtx.globalAlpha = 0.8;
            drawCtx.beginPath();
            drawCtx.ellipse(0, 0, radius * (1 + morph * 0.5), radius * (1 - morph * 0.3), 0, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.globalAlpha = 1;
            break;
        case 'electric_arc':
            // Arcing lightning
            drawCtx.strokeStyle = skin.color;
            drawCtx.lineWidth = 3;
            drawCtx.globalAlpha = 0.7;
            for (let i = 0; i < 3; i++) {
                const startAngle = i * Math.PI * 2 / 3;
                const endAngle = startAngle + Math.PI;
                const midX = Math.cos(startAngle + Math.PI / 2) * radius * 0.5;
                const midY = Math.sin(startAngle + Math.PI / 2) * radius * 0.5;
                drawCtx.beginPath();
                drawCtx.moveTo(Math.cos(startAngle) * radius, Math.sin(startAngle) * radius);
                drawCtx.quadraticCurveTo(midX + (Math.random()-0.5)*10, midY + (Math.random()-0.5)*10, Math.cos(endAngle) * radius, Math.sin(endAngle) * radius);
                drawCtx.stroke();
            }
            drawCtx.globalAlpha = 1;
            break;
        case 'flame_wisp':
            // Floating flames
            for (let i = 0; i < 5; i++) {
                const angle = i * Math.PI * 2 / 5 + time * 0.004;
                const r = radius * 0.3 + Math.sin(time * 0.01 + i) * 5;
                drawCtx.fillStyle = `rgba(255, 69, 0, ${0.6 + Math.sin(time * 0.03 + i) * 0.4})`;
                drawCtx.beginPath();
                drawCtx.arc(Math.cos(angle) * r, Math.sin(angle) * r, 3, 0, Math.PI * 2);
                drawCtx.fill();
            }
            break;
        case 'thorn_vine':
            // FIXED: Enhanced expansion/randomness/jitter/hue variation for chaotic organic feel
            drawCtx.lineWidth = 3;
            for (let i = 0; i < 4; i++) {
                const baseAngle = i * Math.PI / 2;
                const twist = Math.sin(time * 0.005) * 0.2;
                const angle = baseAngle + twist;
                // Greater/random expansion per vine
                let len = radius * (0.8 + Math.random() * 1.2);
                len *= (1 + (Math.random() - 0.5) * 0.3); // Jitter
                len *= (0.5 + 0.5 * Math.sin(time * 0.008 + i)); // Retraction sin
                // Hue variation for alternation
                const hueVar = Math.sin(time * 0.015 + i) * 20; // +/- 20 hue
                const colorAlt = `hsl(${120 + hueVar}, 60%, ${30 + Math.sin(time * 0.01 + i) * 10}%)`; // Green base with var
                drawCtx.strokeStyle = colorAlt;
                drawCtx.globalAlpha = 0.7 + Math.sin(time * 0.015 + i) * 0.3;
                drawCtx.beginPath();
                drawCtx.moveTo(0, 0);
                // Sin wave with per-segment random offset
                for (let seg = 0; seg < 10; seg++) {
                    const prog = seg / 10;
                    let waveX = Math.sin(prog * Math.PI * 4 + time * 0.01) * 2;
                    let waveY = Math.cos(prog * Math.PI * 4 + time * 0.01) * 2;
                    waveX += (Math.random() - 0.5) * 3; // Per-segment random offset
                    waveY += (Math.random() - 0.5) * 3;
                    const px = Math.cos(angle) * len * prog + waveX;
                    const py = Math.sin(angle) * len * prog + waveY;
                    if (seg === 0) drawCtx.moveTo(px, py);
                    else drawCtx.lineTo(px, py);
                }
                drawCtx.stroke();
            }
            drawCtx.globalAlpha = 1;
            break;
        case 'echo_waveform':
            // Oscillating waveforms: draw horizontal bars with vertical sine modulation
            drawCtx.strokeStyle = skin.color;
            drawCtx.lineWidth = 2;
            const numWaves = 4;
            for (let i = 0; i < numWaves; i++) {
                const yOffset = (i - numWaves / 2) * (radius / 2);
                const phase = time * 0.008 + i * Math.PI / 2;
                drawCtx.beginPath();
                for (let x = -radius; x <= radius; x += 2) {
                    const waveHeight = Math.sin(x * 0.1 + phase) * (radius * 0.3);
                    const y = yOffset + waveHeight;
                    if (x === -radius) drawCtx.moveTo(x, y);
                    else drawCtx.lineTo(x, y);
                }
                // Close the wave with a subtle curve back
                drawCtx.lineTo(radius, yOffset);
                drawCtx.lineTo(-radius, yOffset);
                drawCtx.closePath();
                drawCtx.stroke();
            }
            // Add echo pulses: expanding rings
            for (let p = 0; p < 2; p++) {
                const pulseRadius = (time * 0.005 + p * Math.PI * 2) % (radius * 2);
                drawCtx.globalAlpha = 1 - (pulseRadius / (radius * 2));
                drawCtx.beginPath();
                drawCtx.arc(0, 0, pulseRadius, 0, Math.PI * 2);
                drawCtx.stroke();
            }
            drawCtx.globalAlpha = 1;
            break;
        case 'grok_xai':
            // Black hole: black circle with white outline
            drawCtx.beginPath();
            drawCtx.arc(0, 0, radius, 0, Math.PI * 2);
            drawCtx.fillStyle = '#000';
            drawCtx.fill();
            drawCtx.strokeStyle = '#fff';
            drawCtx.lineWidth = 2;
            drawCtx.stroke();
            // Spinning white circles orbiting, with alpha variation to simulate going behind
            const numOrbs = 6;
            const orbRadius = 3;
            const orbitRadius = radius + 8;
            const speed = 0.005;
            for (let i = 0; i < numOrbs; i++) {
                const angle = (time * speed) + (i * Math.PI * 2 / numOrbs);
                const px = Math.cos(angle) * orbitRadius;
                const py = Math.sin(angle) * orbitRadius;
                // Simulate depth: alpha varies to fade when "behind"
                const behindFactor = Math.sin(angle);
                drawCtx.globalAlpha = (behindFactor + 1) / 2 * 0.8 + 0.2; // 0.2 (behind) to 1 (front)
                drawCtx.beginPath();
                drawCtx.arc(px, py, orbRadius, 0, Math.PI * 2);
                drawCtx.fillStyle = '#fff';
                drawCtx.fill();
                drawCtx.globalAlpha = 1;
            }
            break;
    }
    drawCtx.restore();
}
function renderPlayerSkin(dt) {
    const now = Date.now();
    // FIXED: Cat blink cycle to random 1-2s duration loop
    if (player.equippedSkinId === 'cat_txt') {
        if (!player.skinState.catNextChangeTime) {
            player.skinState.catNextChangeTime = now + (1000 + Math.random() * 1000);
        }
        if (now > player.skinState.catNextChangeTime) {
            player.skinState.catFace = (player.skinState.catFace === 'owo') ? '-w-' : 'owo';
            player.skinState.catNextChangeTime = now + (1000 + Math.random() * 1000);
        }
        // Damage/Low HP State (Override)
        const lowHp = player.hp < player.maxHp * 0.3;
        const recentDamage = game.lastDamageTime && (now - game.lastDamageTime < 500);
        if (lowHp || recentDamage) {
            player.skinState.catFace = ';w;';
            player.skinState.catNextChangeTime = now + 3000; // Hold for 3s during damage
        } else if (player.skinState.catFace === ';w;') {
            player.skinState.catFace = 'owo';
            player.skinState.catNextChangeTime = now + (1000 + Math.random() * 1000);
        }
    }
    if (player.equippedSkinId === 'periodic') {
        if (Math.random() < 0.001) { // Rare change
            player.skinState.periodicElement = getRandomPeriodicElement();
        }
    }
    drawSkin(ctx, player.x, player.y, player.radius, player.equippedSkinId, player.skinState, player.hp, player.maxHp, game.lastDamageTime);
}
// --- PREVIEW FUNCTIONS ---
function drawStaticPreview(skinId) {
    const previewCanvas = document.getElementById(`preview-${skinId}`);
    if (!previewCanvas) return;
    const pCtx = previewCanvas.getContext('2d');
    pCtx.clearRect(0, 0, 40, 40);
    const skin = SKIN_CATALOG.find(s => s.id === skinId);
    if (!skin) return;
    pCtx.fillStyle = skin.color;
    pCtx.font = 'bold 20px Inter';
    pCtx.textAlign = 'center';
    pCtx.textBaseline = 'middle';
    pCtx.fillText(skin.preview, 20, 20);
}
function animatePreview(skinId, card) {
    const previewCanvas = document.getElementById(`preview-${skinId}`);
    if (!previewCanvas) return;
    const pCtx = previewCanvas.getContext('2d');
    let previewState = previewStates[skinId];
    if (!previewState) {
        previewStates[skinId] = {
            catNextChangeTime: 0,
            catFace: 'owo',
            periodicElement: getRandomPeriodicElement()
        };
        previewState = previewStates[skinId];
    }
    let animId;
    let lastPreviewTime = performance.now();
    function previewLoop(currentTime) {
        const previewDt = currentTime - lastPreviewTime;
        lastPreviewTime = currentTime;
        const pnow = Date.now();
        // Update state for dynamic skins
        if (skinId === 'cat_txt') {
            if (!previewState.catNextChangeTime) {
                previewState.catNextChangeTime = pnow + (1000 + Math.random() * 1000);
            }
            if (pnow > previewState.catNextChangeTime) {
                previewState.catFace = (previewState.catFace === 'owo') ? '-w-' : 'owo';
                previewState.catNextChangeTime = pnow + (1000 + Math.random() * 1000);
            }
            // No damage in preview
        }
        // Clear and draw
        pCtx.clearRect(0, 0, 40, 40);
        drawSkin(pCtx, 20, 20, 8, skinId, previewState, 100, 100, 0);
        // Continue if still hovering
        if (card.matches(':hover')) {
            animId = requestAnimationFrame(previewLoop);
        } else {
            cancelAnimationFrame(animId);
            drawStaticPreview(skinId);
        }
    }
    animId = requestAnimationFrame(previewLoop);
}
// --- DIGGER SPAWNING AND LOGIC ---
function spawnDigger() {
    const cw = canvas.width, ch = canvas.height;
    const digger = {
        x: Math.random() * cw,
        y: ch + 50,
        vx: (Math.random() - 0.5) * 0.5,
        vy: -1.2,
        size: 12,
        damage: 20,
        color: '#8B4513',
        lifetime: 15000, // 15 seconds max
        update: function(dt) {
            // Simple homing towards player
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 50) {
                this.vx += (dx / dist) * 0.001 * dt;
                this.vy += (dy / dist) * 0.001 * dt;
            }
            this.x += this.vx * dt / 16;
            this.y += this.vy * dt / 16;
            this.lifetime -= dt;
        }
    };
    game.diggers.push(digger);
}
// --- ATTACK ARCHITECTURE (Unique Attack Registry - UAR) ---
// Base Attack Structure
function createAttack(x, y, vx, vy, color, radius, damage, lifetime = Infinity, type = 'basic') {
    return { x, y, vx, vy, color, radius, damage, lifetime, type };
}
// Unique Attack Functions - World 1 Examples
function spawn_A_attack() { // A: Accelerating Aperture (Homing to Center)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 4; i++) {
        const angle = i * Math.PI / 2;
        const x = cw / 2 + Math.cos(angle) * 300;
        const y = ch / 2 + Math.sin(angle) * 300;
        const vx = Math.cos(angle) * 0.5;
        const vy = Math.sin(angle) * 0.5;
        game.attacks.push({
            ..createAttack(x, y, vx, vy, '#ff0000', 8, 10, 8000), {
            update: function(dt) {
                // Accelerate towards center
                const dx = cw / 2 - this.x;
                const dy = ch / 2 - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 100) {
                    this.vx += (dx / dist) * 0.005;
                    this.vy += (dy / dist) * 0.005;
                }
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.lifetime -= dt;
            }
                }));
    }
}
function spawn_B_attack() { // B: Straight-line Stream (Fixed Trajectory)
    const cw = canvas.width, ch = canvas.height;
    const speed = 2.0;
    // Spawn 6 projectiles from random locations near the edge
    for (let i = 0; i < 6; i++) {
        let x, y;
        // Determine if spawning from horizontal (top/bottom) or vertical (left/right) edges
        if (Math.random() < 0.5) {
            x = Math.random() * cw;
            y = Math.random() < 0.5 ? 0 : ch;
        } else {
            x = Math.random() < 0.5 ? 0 : cw;
            y = Math.random() * ch;
        }
        // Calculate straight trajectory towards player's current position (snapshot at spawn)
        const dx = player.x - x;
        const dy = player.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const vx = (dx / dist) * speed;
        const vy = (dy / dist) * speed;
        game.attacks.push({
            ..createAttack(x, y, vx, vy, '#ff9900', 7, 8, 8000),
            // Minimal update: just handle the lifetime. vx/vy remain constant.
            update: function(dt) {
                this.lifetime -= dt;
            }
                }));
    }
}
function spawn_C_attack() { // C: Angular Sweep (Rotating Laser Grid)
    const cw = canvas.width, ch = canvas.height;
    const center_x = cw / 2;
    const center_y = ch / 2;
    const count = 2; // Reduced to 2 beams for better balance
    const thickness = 10;
    const angularSpeed = 0.0005; // radians per millisecond (slow rotation)
    for (let i = 0; i < count; i++) {
        const initialAngle = i * Math.PI / count; // 0 and PI (180 deg)
        const laserLength = Math.max(cw, ch) * 2;
        game.attacks.push({
            x: center_x,
            y: center_y,
            vx: 0,
            vy: 0,
            color: '#ff00cc',
            radius: thickness / 2,
            damage: 10,
            lifetime: 15000,
            type: 'laser',
            width: thickness,
            length: laserLength,
            angle: initialAngle,
     
            update: function(dt) {
                // Rotate the laser line
                this.angle += angularSpeed * dt;
                this.lifetime -= dt;
            },
     
            draw: function(drawCtx) {
                drawCtx.save();
                drawCtx.translate(this.x, this.y);
                drawCtx.rotate(this.angle);
         
                // Draw beam as a long, centered rectangle
                drawCtx.fillStyle = this.color;
                drawCtx.globalAlpha = 0.6;
                drawCtx.fillRect(-this.length / 2, -this.width / 2, this.length, this.width);
                drawCtx.globalAlpha = 1;
         
                // Draw a pulsing core effect
                const coreRadius = this.width / 2;
                drawCtx.fillStyle = '#fff';
                drawCtx.beginPath();
                drawCtx.arc(0, 0, coreRadius * (1 + Math.sin(Date.now() / 100) * 0.2), 0, Math.PI * 2);
                drawCtx.fill();
         
                drawCtx.restore();
            },
     
            isColliding: function(px, py, pr) {
                // Check if the player is within the rotating beam area
                const dx = px - this.x;
                const dy = py - this.y;
         
                // Inverse rotation of player coordinates
                const cosA = Math.cos(-this.angle);
                const sinA = Math.sin(-this.angle);
         
                const rotatedY = dx * sinA + dy * cosA;
         
                // Check collision only against the width of the beam
                const halfWidth = this.width / 2;
         
                return rotatedY + pr > -halfWidth && rotatedY - pr < halfWidth;
            }
                }));
    }
}
function spawn_D_attack() { // D: Drift Net (Slow, Wide Swarm - 1 Damage)
    const cw = canvas.width, ch = canvas.height;
    const count = 15; // High projectile count
    const speed = 0.8; // Slow speed
    for (let i = 0; i < count; i++) {
        // Spawn across the entire height of the screen, slightly off-screen left
        // Add a slight random offset to y for a less rigid pattern
        const yOffset = (Math.random() - 0.5) * 40;
        const x = -50;
        const y = (i / count) * ch + yOffset;
        game.attacks.push({
            ..createAttack(x, y, speed, 0, '#0099ff', 4, 1, 10000), // Damage set to 1
            update: function(dt) {
                // No change in trajectory, just lifetime
                this.lifetime -= dt;
            }
                }));
    }
}
// --- NEW ATTACKS: E, F, and G ---
function spawn_E_attack() { // E: Echo Wave (Oscillating Corridors)
    const cw = canvas.width, ch = canvas.height;
    const waveWidth = 40; // Slightly narrower walls
    // 1. Create two oscillating barrier attacks (non-damaging walls)
    // Wall 1 (Left)
    game.attacks.push({
        x: cw / 4, y: ch / 2, vx: 0, vy: 0,
        color: '#ff66b2', radius: waveWidth / 2, damage: 0, lifetime: 8000, type: 'oscillator',
        width: waveWidth, height: ch, start_x: cw/4, amplitude: cw/8,
        update: function(dt) {
            // Horizontal sine wave oscillation
            this.x = this.start_x + Math.sin(Date.now() / 800) * this.amplitude;
            this.lifetime -= dt;
        },
        draw: function(drawCtx) {
            drawCtx.fillStyle = this.color;
            drawCtx.globalAlpha = 0.2; // Very transparent
            drawCtx.fillRect(this.x - this.width / 2, 0, this.width, this.height);
            // Draw visible lines
            drawCtx.strokeStyle = this.color;
            drawCtx.globalAlpha = 0.5;
            drawCtx.lineWidth = 1;
            drawCtx.strokeRect(this.x - this.width / 2, 0, this.width, this.height);
            drawCtx.globalAlpha = 1;
        },
        isColliding: function(px, py, pr) {
            // Check collision with player
            return px + pr > this.x - this.width / 2 &&
                   px - pr < this.x + this.width / 2;
        }
                }));
    // Wall 2 (Right)
    game.attacks.push({
        x: cw * 3 / 4, y: ch / 2, vx: 0, vy: 0,
        color: '#ff66b2', radius: waveWidth / 2, damage: 0, lifetime: 8000, type: 'oscillator',
        width: waveWidth, height: ch, start_x: cw*3/4, amplitude: cw/8,
        update: function(dt) {
            this.x = this.start_x + Math.sin(Date.now() / 800) * this.amplitude;
            this.lifetime -= dt;
        },
        // Re-use draw and collision logic from Wall 1
        draw: game.attacks[game.attacks.length-2].draw,
        isColliding: game.attacks[game.attacks.length-2].isColliding
    });
    // 2. Create small, low-damage projectiles that move across the screen (The real threat)
    for (let i = 0; i < 6; i++) {
        const x = cw * (0.1 + i * 0.15);
        const y = ch / 2;
        const speed = 1.2 + Math.random();
        game.attacks.push({
            ..createAttack(x, y, 0, speed, '#fff', 5, 8, 8000), // Moderate damage
            update: function(dt) {
                // Reverse direction when hitting top/bottom
                if (this.y < 0 || this.y > ch) {
                    this.vy *= -1;
                }
                this.lifetime -= dt;
            }
                }));
    }
}
function spawn_F_attack() { // F: Focal Point Grid (Converge and Burst)
    const cw = canvas.width, ch = canvas.height;
    // Random focus point, far enough from edges
    const focusX = cw * (0.3 + Math.random() * 0.4);
    const focusY = ch * (0.3 + Math.random() * 0.4);
    const speed = 1.5;
    for (let i = 0; i < 8; i++) {
        // Spawn from random edges
        let x, y;
        const edge = Math.floor(Math.random() * 4); // 0=Top, 1=Bottom, 2=Left, 3=Right
        if (edge === 0) { x = Math.random() * cw; y = 0; }
        else if (edge === 1) { x = Math.random() * cw; y = ch; }
        else if (edge === 2) { x = 0; y = Math.random() * ch; }
        else { x = cw; y = Math.random() * ch; }
 
        // Calculate initial velocity towards the focus point
        const dx = focusX - x;
        const dy = focusY - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
 
        const vx = (dx / dist) * speed;
        const vy = (dy / dist) * speed;
        game.attacks.push({
            ..createAttack(x, y, vx, vy, '#00ffff', 6, 12, 12000), // Medium-high damage
            focusX: focusX,
            focusY: focusY,
            state: 'inbound', // 'inbound' or 'outbound'
            update: function(dt) {
                if (this.state === 'inbound') {
                    const distToFocus = Math.sqrt((this.x - this.focusX)**2 + (this.y - this.focusY)**2);
                    if (distToFocus < 20) { // Near focus point - trigger burst
                        this.state = 'outbound';
                        // Calculate new velocity (burst outwards from focus)
                        const angle = Math.atan2(this.y - this.focusY, this.x - this.focusX) + (Math.random() - 0.5) * 0.5;
                        this.vx = Math.cos(angle) * speed * 2; // Double speed on burst
                        this.vy = Math.sin(angle) * speed * 2;
                        // Draw a visual burst cue
                        startShake(100, 3);
                        showPopup('BURST!', this.focusX, this.focusY, 200, '#ff0000');
                    }
                }
                this.lifetime -= dt;
            }
                }));
    }
}
function spawn_G_attack() { // FIXED: Nerfed G attack (reduced diggers/stagger for playability)
    // Spawn 2 diggers with longer stagger
    for (let i = 0; i < 2; i++) {
        setTimeout(() => {
            if (game.mode !== 'menu' && game.mode !== 'gameover' && game.mode !== 'checkpoints' && game.mode !== 'multi') {
                spawnDigger();
            }
        }, i * 1200); // Stagger by 1200ms
    }
    // Visual cue
    showPopup('DIGGERS INCOMING!', canvas.width / 2, canvas.height - 50, 1500, '#8B4513');
}
function spawn_H_attack() { // H: Horizontal Barrage (Waves of horizontal lines)
    const cw = canvas.width, ch = canvas.height;
    const numWaves = 5;
    const speed = 1.8;
    for (let wave = 0; wave < numWaves; wave++) {
        setTimeout(() => {
            if (game.mode !== 'menu' && game.mode !== 'gameover' && game.mode !== 'checkpoints' && game.mode !== 'multi') {
                for (let i = 0; i < 6; i++) {
                    const y = wave * (ch / (numWaves + 1));
                    game.attacks.push({
                        ..createAttack(-20, y, speed, 0, '#ff4444', 6, 6, 8000), {
            update: function(dt) {
                            this.x += this.vx * dt / 16;
                            this.lifetime -= dt;
                        }
                }));
                }
            }
        }, wave * 1000);
    }
}
function spawn_I_attack() { // I: Interlocking Rings (Expanding concentric circles)
    const cw = canvas.width, ch = canvas.height;
    const centerX = cw / 2, centerY = ch / 2;
    for (let i = 0; i < 5; i++) {
        const radius = 50 + i * 40;
        game.attacks.push({
            x: centerX, y: centerY, vx: 0, vy: 0,
            color: '#44ff44', radius: 3, damage: 7, lifetime: 10000, type: 'ring',
            ringRadius: radius,
            expansionSpeed: 0.8 + i * 0.2,
            update: function(dt) {
                this.ringRadius += this.expansionSpeed;
                this.lifetime -= dt;
            },
            draw: function(drawCtx) {
                drawCtx.strokeStyle = this.color;
                drawCtx.lineWidth = this.radius * 2;
                drawCtx.beginPath();
                drawCtx.arc(this.x, this.y, this.ringRadius, 0, Math.PI * 2);
                drawCtx.stroke();
            },
            isColliding: function(px, py, pr) {
                const dist = Math.sqrt((px - this.x)**2 + (py - this.y)**2);
                return Math.abs(dist - this.ringRadius) < pr + this.radius;
            }
                }));
    }
}
function spawn_Z_attack() { // Z: Zonal Collapse (Zig-zag)
    const cw = canvas.width, ch = canvas.height;
    const count = 5;
    for (let i = 0; i < count; i++) {
        const x = cw / 2;
        const y = ch / 2;
        const angle = (Math.PI * 2 / count) * i;
        const vx = Math.cos(angle) * 3;
        const vy = Math.sin(angle) * 3;
        game.attacks.push({
            ..createAttack(x, y, vx, vy, '#00ffcc', 6, 15, 6000),
            state: 0, // 0: out, 1: zig-zag in
            maxDist: 300,
            update: function(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                const distFromCenter = Math.sqrt((this.x - cw / 2)**2 + (this.y - ch / 2)**2);
                if (distFromCenter > this.maxDist && this.state === 0) {
                    this.state = 1;
                }
                if (this.state === 1) {
                    // Zig-zag back towards center
                    this.vx = (cw / 2 - this.x) * 0.002 * Math.sin(Date.now() / 200);
                    this.vy = (ch / 2 - this.y) * 0.002 * Math.cos(Date.now() / 200);
                }
                this.lifetime -= dt;
            }
                }));
    }
}
// Unique Attack Functions - World 2 Examples
function spawn_Enter_attack() { // Enter: The Hard Commit (Vertical Beams)
    const cw = canvas.width, ch = canvas.height;
    // Create large, slow moving vertical beams
    for (let i = 0; i < 3; i++) {
        const x = cw / 4 + i * cw / 4;
        const width = 30;
        const speed = 0.5;
        game.attacks.push({
            x: x, y: -ch / 2, vx: 0, vy: speed,
            color: '#ff6600', radius: width / 2, damage: 30, lifetime: 10000, type: 'beam',
            width: width, height: ch * 2,
            update: function(dt) {
                this.y += this.vy * dt;
                this.vy += 0.001; // Gravity effect
                if (this.y > ch + ch / 2) this.lifetime = 0;
            },
            draw: function(drawCtx) {
                drawCtx.fillStyle = this.color;
                drawCtx.globalAlpha = 0.5;
                drawCtx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                drawCtx.globalAlpha = 1;
            },
            isColliding: function(px, py, pr) {
                // Check AABB collision
                return px + pr > this.x - this.width / 2 &&
                       px - pr < this.x + this.width / 2 &&
                       py + pr > this.y - this.height / 2 &&
                       py - pr < this.y + this.height / 2;
            }
                }));
    }
}
function spawn_ArrowRight_attack() { // ArrowRight: Directional Current
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 10; i++) {
        const x = cw * 0.1;
        const y = Math.random() * ch;
        const speed = 1 + Math.random();
        game.attacks.push({
            ..createAttack(x, y, speed, 0, '#00bfff', 5, 5, 8000),
            baseVx: speed,
            update: function(dt) {
                // Persistent force field pushes right
                this.vx = this.baseVx + 0.1 * dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                if (this.x > cw + 100) this.lifetime = 0;
                this.lifetime -= dt;
            }
                }));
    }
}
const UNIQUE_ATTACK_REGISTRY = {
    // World 1 Unique Attacks
    'a': spawn_A_attack,
    'b': spawn_B_attack,
    'c': spawn_C_attack,
    'd': spawn_D_attack,
    'e': spawn_E_attack, // <-- NEW E
    'f': spawn_F_attack, // <-- NEW F
    'g': spawn_G_attack, // <-- FIXED: Nerfed G
    'h': spawn_H_attack, // <-- NEW H: To avoid fallback duplication
    'i': spawn_I_attack, // <-- NEW I: To avoid fallback duplication
    'z': spawn_Z_attack,
    // World 2 Unique Attacks
    'Enter': spawn_Enter_attack,
    'ArrowRight': spawn_ArrowRight_attack,
    // NOTE: All other keys (j-y, 0-9, symbols, unicode) now use an easier fallback (straight edge shots),
    // ensuring no homing duplication and balanced difficulty.
};
function spawnPatternForStage(stageKey) {
    const key = stageKey.toLowerCase();
    // Check if a unique attack is defined
    if (UNIQUE_ATTACK_REGISTRY[key]) {
        UNIQUE_ATTACK_REGISTRY[key]();
    } else {
        // Easier Fallback: Straight-line shots from all edges (no homing, lower damage)
        const cw = canvas.width, ch = canvas.height;
        const sides = 4;
        const numShotsPerSide = 4;
        const speed = 1.2;
        for (let side = 0; side < sides; side++) {
            for (let i = 0; i < numShotsPerSide; i++) {
                let x, y, vx, vy;
                const spacing = cw / (numShotsPerSide + 1);
                if (side === 0) { // Top
                    x = (i + 1) * spacing;
                    y = -20;
                    vx = 0;
                    vy = speed;
                } else if (side === 1) { // Bottom
                    x = (i + 1) * spacing;
                    y = ch + 20;
                    vx = 0;
                    vy = -speed;
                } else if (side === 2) { // Left
                    x = -20;
                    y = (i + 1) * spacing;
                    vx = speed;
                    vy = 0;
                } else { // Right
                    x = cw + 20;
                    y = (i + 1) * spacing;
                    vx = -speed;
                    vy = 0;
                }
                game.attacks.push({
                    ..createAttack(x, y, vx, vy, '#888888', 5, 4, 6000), {
            update: function(dt) {
                        this.lifetime -= dt;
                    }
                }));
            }
        }
    }
}
// --- GAME FLOW AND STATE MANAGEMENT ---
function showMenu() {
    // Stop the game loop
    if (game.animationFrameId) {
        cancelAnimationFrame(game.animationFrameId);
        game.animationFrameId = null;
    }
    // Reset state and hide HUD/Canvas elements
    game.mode = 'menu';
    game.winning = false;
    cleanupRoom(); // FIXED: Multiplayer - Cleanup on menu
    // Hide all game-related UI
    hud.classList.add('hidden');
    canvas.style.display = 'none';
    // Show menu UI
    menu.classList.remove('hidden');
    gameover.classList.add('hidden');
    shop.classList.add('hidden');
    multiplayerLobby.classList.add('hidden');
    victory.classList.add('hidden');
    keypad.classList.add('hidden');
    // Reset displays for main menu
    document.getElementById('main-menu-buttons').style.display = '';
    skinsShopBtn.style.display = '';
    backToMenuBtn.style.display = 'none';
    updateHUD();
}
function showCheckpoints() {
    // Stop the game loop if running
    if (game.animationFrameId) {
        cancelAnimationFrame(game.animationFrameId);
        game.animationFrameId = null;
    }
    cleanupRoom();
    // Set mode to checkpoints
    game.mode = 'checkpoints';
    game.winning = false;
    // Hide HUD/Canvas
    hud.classList.add('hidden');
    canvas.style.display = 'none';
    // Show menu background and build keypad, but hide main buttons
    menu.classList.remove('hidden');
    gameover.classList.add('hidden');
    shop.classList.add('hidden');
    multiplayerLobby.classList.add('hidden');
    victory.classList.add('hidden');
    document.getElementById('main-menu-buttons').style.display = 'none';
    skinsShopBtn.style.display = 'none';
    backToMenuBtn.style.display = '';
    buildKeypad();
    updateHUD();
}
backToMenuBtn.onclick = () => {
    document.getElementById('main-menu-buttons').style.display = '';
    skinsShopBtn.style.display = '';
    backToMenuBtn.style.display = 'none';
    keypad.classList.add('hidden');
    hostKeypad.classList.add('hidden');
};
multiBackBtn.onclick = showMenu;
hostGameBtn.onclick = hostGame;
joinGameBtn.onclick = joinGame;
startGameBtn.onclick = startMultiGame;
function startGame(playMode, world, stageKey) {
    if (playMode === 'precoded-uni' && !progress.world1) { // Check for world 1 completion
        startShake(300, 8);
        showPopup('World 2 Locked: Complete World 1 first!', canvas.width / 2, canvas.height / 2, 2000, '#f55');
        return;
    }
    cleanupRoom(); // FIXED: Ensure clean start
    game.mode = 'playing';
    if (playMode === 'multi') game.mode = 'multi';
    game.world = world;
    game.stageKey = stageKey;
    game.timer = 8 + Math.random() * 4; // Reset timer
    player.hp = player.maxHp;
    player.shield = 0;
    player.dead = false;
    game.attacks = [];
    game.diggers = []; // Reset diggers
    game.winning = false;
    game.lastTime = performance.now();
    // Reset player position to center of the canvas
    player.x = canvas.width / 2;
    player.y = canvas.height / 2;
    // Periodic Table skin logic on spawn
    if (player.equippedSkinId === 'periodic') {
        player.skinState.periodicElement = getRandomPeriodicElement();
    }
    // For cat, init next change if needed
    if (player.equippedSkinId === 'cat_txt' && !player.skinState.catNextChangeTime) {
        player.skinState.catNextChangeTime = Date.now() + (1000 + Math.random() * 1000);
    }
    // Hide menus and show game elements
    menu.classList.add('hidden');
    gameover.classList.add('hidden');
    victory.classList.add('hidden');
    shop.classList.add('hidden');
    multiplayerLobby.classList.add('hidden');
    hud.classList.remove('hidden');
    canvas.style.display = 'block';
    keypad.classList.add('hidden');
    hostKeypad.classList.add('hidden');
    // Update HUD now that game state is set
    updateHUD();
    // Start the loop
    if (!game.animationFrameId) {
        game.animationFrameId = requestAnimationFrame(mainLoop);
    }
}
function nextStage() {
    const keyset = game.world === 'world1' ? WORLD1_KEYS : WORLD2_FULL;
    game.stageIndex++;
    if (game.stageIndex >= keyset.length) {
        // World completion logic - only trigger full win on the last stage
        let worldDisplay = game.world === 'world1' ? '1' : '2';
        if (game.world === 'world1') {
            progress.world1 = true;
            progress.unlockedKeys = [...new Set([...progress.unlockedKeys, ...WORLD1_KEYS])];
            showPopup('WORLD 1 CLEARED! World 2 Unlocked!', canvas.width / 2, canvas.height / 2, 3000, '#00ff44');
        } else {
            progress.world2 = true;
            progress.unlockedKeys = [...new Set([...progress.unlockedKeys, ...WORLD2_FULL])];
            showPopup('WORLD 2 CLEARED! You Win!', canvas.width / 2, canvas.height / 2, 3000, '#00ff44');
        }
 
        saveProgress();
        // Show victory screen instead of menu
        game.mode = 'victory';
        document.getElementById('victoryMsg').textContent = `World ${worldDisplay} Completed!`;
        hud.classList.add('hidden');
        canvas.style.display = 'none';
        menu.classList.add('hidden');
        gameover.classList.add('hidden');
        shop.classList.add('hidden');
        multiplayerLobby.classList.add('hidden');
        victory.classList.remove('hidden');
        return;
    }
    // Seamless progression to next stage without returning to menu
    game.stageKey = keyset[game.stageIndex];
    game.timer = 8 + Math.random() * 4;
    game.lastTime = performance.now(); // Fix: Reset lastTime to prevent large dt
    game.attacks = [];
    game.diggers = []; // Clear diggers for new stage
    game.winning = false; // FIXED: Wave Win Freeze - Explicitly clear winning flag
    // Reset player position to center
    player.x = canvas.width / 2;
    player.y = canvas.height / 2;
    // Periodic Table skin logic on wave completion
    if (player.equippedSkinId === 'periodic') {
        player.skinState.periodicElement = getRandomPeriodicElement();
    }
    updateHUD();
    // FIXED: Wave Win Freeze - Force micro-task frame restart
    setTimeout(() => {
        if (!game.animationFrameId) {
            game.animationFrameId = requestAnimationFrame(mainLoop);
        }
    }, 0);
}
function gameWin() {
    if (game.winning) return; // Prevent multiple calls
    game.winning = true;
    // 1. Credit Calculation
    const hpRatio = player.hp / player.maxHp;
    const creditsGained = BASE_CREDITS + Math.floor(hpRatio * BONUS_CREDITS);
    player.credits += creditsGained;
    showPopup(`+${creditsGained} Credits!`, canvas.width / 2, canvas.height / 2 + 50, 1500, '#ffeb3b');
    // 2. Full health and shield regeneration (Requested feature)
    player.hp = player.maxHp;
    player.shield = MAX_SHIELD;
    showPopup('System Refreshed: HP & Shield Maxed!', canvas.width / 2, canvas.height / 2 - 50, 1500, '#00bfff');
    // 3. Unlock Key
    if (!progress.unlockedKeys.includes(game.stageKey)) {
        progress.unlockedKeys.push(game.stageKey);
        progress.unlockedKeys = Array.from(new Set(progress.unlockedKeys)); // ensure unique
        showPopup(`'${game.stageKey.toUpperCase()}' Unlocked!`, canvas.width / 2, canvas.height / 2 + 100, 1500, '#00bfff');
    }
    saveProgress(); // Save state immediately
    // Use nextStage for all modes - for checkpoints, it will progress sequentially within the world
    nextStage();
}
function gameOver() {
    player.dead = true;
    game.mode = 'gameover';
    game.winning = false;
    cleanupRoom();
    // Stop the game loop
    if (game.animationFrameId) {
        cancelAnimationFrame(game.animationFrameId);
        game.animationFrameId = null;
    }
    // Hide HUD/Canvas and show gameover screen
    hud.classList.add('hidden');
    canvas.style.display = 'none';
    gameover.classList.remove('hidden');
    menu.classList.add('hidden');
    victory.classList.add('hidden');
    shop.classList.add('hidden');
    multiplayerLobby.classList.add('hidden');
    document.getElementById('finalScore').textContent = `Final Stage: ${game.stageKey.toUpperCase()} (Wave ${game.stageIndex + 1})`;
    startShake(1000, 10);
}
// --- MAIN LOOP ---
function mainLoop(time) {
    // FIXED: Wave Win Freeze - Debug log (remove in production)
    // console.log('mainLoop running, mode:', game.mode, 'winning:', game.winning);
    if (game.mode === 'menu' || game.mode === 'gameover' || game.mode === 'victory' || game.mode === 'shop' || game.mode === 'checkpoints' || game.winning) {
        if (game.animationFrameId) {
             cancelAnimationFrame(game.animationFrameId);
             game.animationFrameId = null;
        }
        return;
    }
    const dt = time - game.lastTime;
    game.lastTime = time;
    const cw = canvas.width, ch = canvas.height;
    // 1. Update Game State
    game.timer -= dt / 1000;
    if (game.timer <= 0) {
        gameWin();
        return; // Stop this frame, loop will be handled in gameWin
    }
    // Player movement update (using simple mouse follow for now)
    player.x = Math.max(player.radius, Math.min(cw - player.radius, player.x + (mouse.x - player.x) * 0.1));
    player.y = Math.max(player.radius, Math.min(ch - player.radius, player.y + (mouse.y - player.y) * 0.1));
    // 2. Attack Spawning
    if (Math.random() < 0.05) { // Spawn new pattern every 20 frames on average
        spawnPatternForStage(game.stageKey);
    }
    // 3. Update Attacks and Check Collisions
    game.attacks = game.attacks.filter(attack => {
        // Base movement
        if (attack.update) attack.update(dt);
        attack.x += attack.vx * dt / 16;
        attack.y += attack.vy * dt / 16;
        // Collision Check
        const attackRadius = attack.radius || 10;
 
        let collision = false;
        if (attack.isColliding) {
            collision = attack.isColliding(player.x, player.y, player.radius);
        } else {
            const dx = player.x - attack.x;
            const dy = player.y - attack.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            collision = dist < player.radius + attackRadius;
        }
        if (collision) {
            const damage = attack.damage || 5;
            let finalDamage = damage;
            if (player.shield > 0) {
                const shieldAbsorbed = Math.min(player.shield, finalDamage);
                player.shield -= shieldAbsorbed;
                finalDamage -= shieldAbsorbed;
            }
            if (finalDamage > 0) {
                player.hp -= finalDamage;
                game.lastDamageTime = Date.now();
                startShake(150, 5);
                // Only show damage popup if damage was actually taken
                if (Math.round(finalDamage) > 0) {
                     showPopup(`-${Math.round(finalDamage)} HP`, player.x, player.y - 20, 500, '#f55');
                }
            }
            if (player.hp <= 0) {
                gameOver();
                return false; // Remove attack on hit
            }
            // Only remove projectile if it actually deals damage, otherwise let passive threats persist.
            if (attack.damage > 0) {
                return false; // Remove attack on hit
            }
        }
        // Lifetime and boundary check
        return attack.lifetime > 0 &&
               attack.x > -100 && attack.x < cw + 100 &&
               attack.y > -100 && attack.y < ch + 100;
    });
    // 4. Update Diggers and Check Collisions
    game.diggers = game.diggers.filter(digger => {
        if (digger.update) digger.update(dt);
        digger.x += digger.vx * dt / 16;
        digger.y += digger.vy * dt / 16;
        // Collision Check
        const dx = player.x - digger.x;
        const dy = player.y - digger.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const collision = dist < player.radius + digger.size;
        if (collision) {
            let finalDamage = digger.damage;
            if (player.shield > 0) {
                const shieldAbsorbed = Math.min(player.shield, finalDamage);
                player.shield -= shieldAbsorbed;
                finalDamage -= shieldAbsorbed;
            }
            if (finalDamage > 0) {
                player.hp -= finalDamage;
                game.lastDamageTime = Date.now();
                startShake(200, 6);
                showPopup(`-${finalDamage} HP`, player.x, player.y - 20, 500, '#8B4513');
            }
            if (player.hp <= 0) {
                gameOver();
                return false;
            }
            return false; // Remove digger on hit
        }
        // Lifetime and boundary check
        return digger.lifetime > 0 &&
               digger.y > -50;
    });
    // 4. Draw Everything
    ctx.clearRect(0, 0, cw, ch);
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, cw, ch);
    // FIX: Use ctx.save() and ctx.restore() to contain the screen shake translation
    ctx.save();
    // Apply shake offset
    const shakeX = Math.random() * game.shake - game.shake / 2;
    const shakeY = Math.random() * game.shake - game.shake / 2;
    ctx.translate(shakeX, shakeY);
    // Draw Attacks
    game.attacks.forEach(attack => {
        if (attack.draw) {
            attack.draw(ctx);
        } else {
            ctx.fillStyle = attack.color || '#fff';
            ctx.beginPath();
            ctx.arc(attack.x, attack.y, attack.radius || 10, 0, Math.PI * 2);
            ctx.fill();
        }
                }));
    // Draw Diggers
    game.diggers.forEach(digger => {
        ctx.fillStyle = digger.color;
        ctx.fillRect(digger.x - digger.size / 2, digger.y - digger.size / 2, digger.size, digger.size);
        // Simple "digging" trail
        ctx.fillStyle = 'rgba(139, 69, 19, 0.3)';
        ctx.fillRect(digger.x - digger.size / 2, digger.y + digger.size / 2, digger.size, 8);
    });
    // Draw Player
    renderPlayerSkin(dt);
    // Draw Shield
    if (player.shield > 0) {
        const shieldRatio = player.shield / MAX_SHIELD;
        ctx.strokeStyle = `rgba(0, 150, 255, ${0.5 + shieldRatio * 0.5})`;
        ctx.lineWidth = 5 * shieldRatio;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
        ctx.stroke();
    }
    // Draw Health Bar
    const hpRatio = player.hp / player.maxHp;
    ctx.fillStyle = hpRatio > 0.5 ? '#0f0' : (hpRatio > 0.2 ? '#ff0' : '#f00');
    ctx.fillRect(player.x - 15, player.y + player.radius + 5, 30 * hpRatio, 3);
    ctx.restore(); // Restores context, automatically resetting the translate (shake)
    // 5. Update HUD and Loop
    updateHUD();
    game.animationFrameId = requestAnimationFrame(mainLoop);
}
// --- MENU AND KEYPAD LOGIC ---
function buildKeypad() {
    keypad.innerHTML = '';
    const worldKeys = [...WORLD1_KEYS, ...WORLD2_FULL];
    // FIXED: Ensure no duplicates in stages (unique keys already, but dedupe for safety)
    const uniqueKeys = [...new Set(worldKeys)];
    uniqueKeys.forEach(k => {
        const keybtn = document.createElement('div');
        keybtn.className = 'key-btn';
        // Show ? for locked, key for unlocked
        keybtn.textContent = progress.unlockedKeys.includes(k) ? k.toUpperCase() : '?';
        // Check for locking
        const isUnlocked = progress.unlockedKeys.includes(k);
        if (!isUnlocked) {
            keybtn.classList.add('locked');
            keybtn.title = 'Complete this stage in Precoded Mode to unlock.';
        } else {
            keybtn.onclick = () => startChoiceStage(k);
        }
        if (k === game.stageKey) {
            keybtn.classList.add('current');
        }
        keypad.appendChild(keybtn);
    });
    // Show keypad
    keypad.classList.remove('hidden');
}
function startChoiceStage(k) {
    let world = WORLD1_KEYS.includes(k) ? 'world1' : 'world2';
    let keyset = world === 'world1' ? WORLD1_KEYS : WORLD2_FULL;
    game.stageIndex = keyset.indexOf(k);
    if (game.stageIndex === -1) {
        console.error("Key not found in expected world set:", k);
        return;
    }
    // Hide Keypad and start game
    keypad.classList.add('hidden');
    startGame('playing', world, k);
}
// --- SKINS SHOP LOGIC ---
function showSkinsShop() {
    menu.classList.add('hidden');
    shop.classList.remove('hidden');
    renderShopCatalog();
}
function renderShopCatalog() {
    const catalogContainer = document.getElementById('skinCatalog');
    catalogContainer.innerHTML = '';
    document.getElementById('shopCredits').textContent = player.credits;
    SKIN_CATALOG.forEach(skin => {
        const card = document.createElement('div');
        card.className = 'skin-card';
        card.innerHTML = `
            <h3>${skin.name}</h3>
            <div class="preview">
                <canvas id="preview-${skin.id}" width="40" height="40"></canvas>
            </div>
            <p>${skin.desc}</p>
            <div class="actions"></div>
        `;
        const actionsDiv = card.querySelector('.actions');
        const isOwned = progress.ownedSkins.includes(skin.id);
        const isEquipped = player.equippedSkinId === skin.id;
        if (isEquipped) {
            actionsDiv.innerHTML = `<button disabled>EQUIPPED</button>`;
        } else if (isOwned) {
            const equipBtn = document.createElement('button');
            equipBtn.textContent = 'EQUIP';
            equipBtn.onclick = () => equipSkin(skin.id);
            actionsDiv.appendChild(equipBtn);
        } else {
            const purchaseBtn = document.createElement('button');
            const canAfford = player.credits >= skin.price;
     
            purchaseBtn.textContent = `BUY - ${skin.price} CR`;
            purchaseBtn.disabled = !canAfford;
            purchaseBtn.classList.toggle('disabled', !canAfford);
     
            if (canAfford) {
                purchaseBtn.onclick = () => purchaseSkin(skin.id, skin.price);
            } else {
                purchaseBtn.title = 'Not enough credits!';
            }
            actionsDiv.appendChild(purchaseBtn);
        }
        // Add hover events for preview animation
        card.onmouseenter = () => animatePreview(skin.id, card);
        card.onmouseleave = () => drawStaticPreview(skin.id);
        // Initial static draw
        drawStaticPreview(skin.id);
        catalogContainer.appendChild(card);
    });
}
function equipSkin(skinId) {
    player.equippedSkinId = skinId;
    saveProgress();
    renderShopCatalog(); // Refresh shop view
    showPopup(`Equipped ${skinId}!`, canvas.width/2, canvas.height/2, 1000, '#00ff44');
}
function purchaseSkin(skinId, price) {
    if (player.credits >= price) {
        player.credits -= price;
        progress.ownedSkins.push(skinId);
        player.equippedSkinId = skinId; // Auto-equip on purchase
 
        saveProgress();
        renderShopCatalog(); // Refresh shop view
        updateHUD();
 
        showPopup(`Purchased & Equipped ${skinId}!`, canvas.width/2, canvas.height/2, 2000, '#ffeb3b');
    } else {
        showPopup(`Not enough credits!`, canvas.width/2, canvas.height/2, 1000, '#f55');
    }
}
// --- CHEAT CODE HANDLING ---
cheatInput.addEventListener('input', (e) => {
    const code = e.target.value.toLowerCase();
    if (code === 'nexus7') {
        SKIN_CATALOG.forEach(skin => {
            if (!progress.ownedSkins.includes(skin.id)) {
                progress.ownedSkins.push(skin.id);
            }
                }));
        player.credits = 999999;
        progress.credits = player.credits;
        saveProgress();
        e.target.value = '';
    }
                }));
// --- EVENT LISTENERS AND INITIALIZATION ---
let mouse = { x: 0, y: 0 };
window.onmousemove = e => { mouse.x = e.clientX; mouse.y = e.clientY; };
window.ontouchmove = e => { if (e.touches.length > 0) { mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; e.preventDefault(); }};
window.onresize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
};
// Menu Button Wiring (FIX: Always start at stage 0 for Precoded modes)
precodedBtn.onclick = () => {
    game.stageIndex = 0;
    game.stageKey = WORLD1_KEYS[0];
    startGame('precoded', 'world1', WORLD1_KEYS[0]);
};
precodedUniBtn.onclick = () => {
    if (!progress.world1) { // World 2 requires World 1 completion
        startShake(300, 8);
        showPopup('Locked: Complete World 1 first!', canvas.width / 2, canvas.height / 2, 2000, '#f55');
        return;
    }
    game.stageIndex = 0; // FIX: Ensure stage index is reset
    game.stageKey = WORLD2_FULL[0];
    startGame('precoded-uni', 'world2', WORLD2_FULL[0]);
};
// Checkpoints button now shows the checkpoints view
yourChoiceBtn.onclick = showCheckpoints;
multiplayerBtn.onclick = showMultiplayerLobby;
skinsShopBtn.onclick = showSkinsShop;
shopBackBtn.onclick = () => { shop.classList.add('hidden'); menu.classList.remove('hidden'); };
// Key R restart
document.addEventListener('keydown', e => {
    if (e.key === 'r' || e.key === 'R') {
        player.hp = player.maxHp;
        player.shield = 0;
        player.dead = false;
        game.attacks = [];
        game.diggers = [];
        game.winning = false;
        showMenu(); // Use the dedicated function to clean up and transition
    }
                }));
// Initial Setup
window.onload = function () {
    window.onresize(); // Set initial canvas size
    showMenu(); // Ensure the menu is shown initially and the game loop is stopped
};
</script>
</body>
</html>
