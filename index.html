<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>TYPING TITANS: KEYBOARD ARENA â€” V2 System (Team Mode Enabled)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<script src="https://cdn.tailwindcss.com"></script>
<style>
/* Global Styles (Preserved from Original Script) */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#000; overflow:hidden; touch-action:none; font-family: 'Inter', sans-serif; }
canvas { display:block; image-rendering:pixelated; cursor:none; }
/* Game UI Overlays */
#hud { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; color:#fff; }
.topleft { position:absolute; top:10px; left:10px; font-size:14px; text-shadow: 0 0 5px #0f0; }
.topright { position:absolute; top:10px; right:10px; font-size:14px; text-shadow: 0 0 5px #0f0; } /* Adjusted position for teammate/boss HP */
.centertop { position:absolute; top:10px; left:50%; transform:translateX(-50%); font-size:18px; font-weight:bold; color: #ffeb3b; text-shadow: 0 0 8px #ffeb3b; }
.bottomcenter { position:absolute; bottom:10px; left:50%; transform:translateX(-50%); display:flex; gap:10px; }
/* Main Menu and Panels */
.menu-panel {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 500px;
    padding: 20px;
    background: #111;
    border: 3px solid #333;
    border-radius: 12px;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    color: #fff;
    text-align: center;
    z-index: 1000;
}
.menu-panel h1 {
    font-size: 28px;
    font-weight: bold;
    color: #0f0;
    text-shadow: 0 0 10px #0f0;
    margin-bottom: 20px;
}
.menu-button {
    width: 100%;
    padding: 15px;
    margin-bottom: 10px;
    background: #005500;
    color: #fff;
    border: 2px solid #00ff00;
    border-radius: 8px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s, box-shadow 0.2s, transform 0.1s;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
    text-transform: uppercase;
}
.menu-button:hover {
    background: #007700;
    box-shadow: 0 0 15px #00ff00;
}
.menu-button:active {
    transform: scale(0.98);
}
.skin-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 15px;
    max-height: 400px;
    overflow-y: auto;
    padding: 10px;
    border: 1px solid #333;
    border-radius: 8px;
    background: #0a0a0a;
}
.skin-item {
    padding: 10px;
    border: 2px solid #333;
    border-radius: 8px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
}
.skin-item:hover {
    box-shadow: 0 0 15px #0ff;
    transform: translateY(-2px);
}
.skin-item.equipped {
    border-color: #0ff;
    box-shadow: 0 0 20px #0ff;
    background: #1a1a1a;
}
.skin-item.locked {
    filter: grayscale(100%);
    opacity: 0.5;
    cursor: default;
}
.skin-preview {
    font-size: 48px;
    margin-bottom: 5px;
    height: 50px;
    line-height: 50px;
}
.skin-name {
    font-size: 14px;
    font-weight: bold;
    color: #fff;
}
.skin-price {
    font-size: 12px;
    color: #ff0;
}
.skin-status {
    font-size: 12px;
    color: #0f0;
}
.currency-display {
    font-size: 20px;
    font-weight: bold;
    color: #ff0;
    margin-bottom: 15px;
    text-shadow: 0 0 5px #ff0;
}
/* Health and Shields (HUD) */
.health-bar-container {
    width: 200px;
    height: 20px;
    background: #333;
    border: 2px solid #fff;
    border-radius: 5px;
    overflow: hidden;
}
.health-bar {
    height: 100%;
    background: linear-gradient(to right, #f00, #ff0);
    transition: width 0.3s;
}
.shield-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: rgba(0, 191, 255, 0.6);
    transition: width 0.3s;
}
/* Chat/Multiplayer Overlay */
#multiplayer-overlay {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 300px;
    height: 200px;
    background: rgba(0, 0, 0, 0.8);
    border-top: 2px solid #0f0;
    border-left: 2px solid #0f0;
    display: flex;
    flex-direction: column;
    padding: 5px;
    z-index: 100;
}
#chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    color: #fff;
    font-size: 12px;
    padding: 5px;
    margin-bottom: 5px;
}
#chat-input-container {
    display: flex;
}
#chat-input {
    flex-grow: 1;
    padding: 5px;
    background: #333;
    color: #fff;
    border: none;
}
#chat-send {
    padding: 5px 10px;
    background: #0f0;
    color: #000;
    border: none;
    cursor: pointer;
}
/* Utility */
.hidden { display: none !important; }
.text-flair { color: #ffeb3b; text-shadow: 0 0 5px #ffeb3b; }
.text-error { color: #f00; text-shadow: 0 0 5px #f00; }
.text-success { color: #0f0; text-shadow: 0 0 5px #0f0; }

/* Custom Boss Styling */
.health-boss .health-bar {
    background: linear-gradient(to right, #800000, #ff4500);
}
</style>
</head>
<body>

<div id="app" class="relative w-screen h-screen">
    <canvas id="canvas" class="w-full h-full"></canvas>

    <!-- Main Menu Panel -->
    <div id="menu" class="menu-panel">
        <h1>TYPING TITANS: KEYBOARD ARENA</h1>
        <p class="mb-5 text-gray-400">Battle the key or challenge a friend.</p>

        <div id="solo-section" class="mb-5">
            <h2 class="text-xl text-flair mb-3">Solo Training</h2>
            <button id="precodedBtn" class="menu-button">Start Arena (Solo V1)</button>
            <button id="precodedUniBtn" class="menu-button">Start Arena (Solo V2 - Unicode)</button>
        </div>

        <div id="multiplayer-section" class="mb-5">
            <h2 class="text-xl text-flair mb-3">Multiplayer Arena (WebRTC)</h2>
            <button id="multiplayerDuelBtn" class="menu-button bg-red-800 border-red-500 hover:bg-red-900">1V1 DUEL (Opponent HP)</button>
            <button id="multiplayerTeamBtn" class="menu-button bg-purple-800 border-purple-500 hover:bg-purple-900">2V1 TEAM ARENA (Boss HP)</button>
        </div>

        <button id="skinsShopBtn" class="menu-button bg-blue-800 border-blue-500 hover:bg-blue-900">Skins Shop</button>

        <div class="mt-8 text-xs text-gray-500">
            Development Assisted by <span class="text-green-500 font-bold">HARP & REX</span>
        </div>
    </div>

    <!-- Skins Shop Panel -->
    <div id="shop" class="menu-panel hidden">
        <h1 class="text-blue-400">ARENA SKINS SHOP</h1>
        <div class="currency-display mb-3">
            <span id="playerMoney"></span> Gold
        </div>
        <div id="skin-grid" class="skin-grid mb-5">
            <!-- Skin items will be injected here by JavaScript -->
        </div>
        <button id="shopBackBtn" class="menu-button bg-gray-600 border-gray-400 hover:bg-gray-700">Back to Menu</button>
    </div>

    <!-- Multiplayer Lobby Panel -->
    <div id="multiplayer-lobby" class="menu-panel hidden">
        <h1 id="lobby-title" class="text-red-400">WebRTC LOBBY</h1>
        <p class="text-sm text-gray-400 mb-5" id="lobby-description">Start a peer-to-peer connection for a real 1v1 duel or 2v1 team fight.</p>

        <div id="lobby-state" class="p-3 mb-5 border border-red-500 rounded text-left bg-gray-800">
            <p id="rtc-status" class="text-sm">Status: <span class="text-flair">Idle</span></p>
            <p class="text-sm">Your Peer ID (Copy/Paste):</p>
            <input type="text" id="local-peer-id" readonly class="w-full p-2 mt-1 text-xs bg-gray-900 border border-red-700 rounded text-red-300 select-all" value="Generating ID..." />
        </div>

        <p class="text-sm text-gray-400 mb-2">Enter Opponent's Peer ID:</p>
        <input type="text" id="remote-peer-id" placeholder="Paste ID here..." class="w-full p-3 mb-3 bg-gray-700 border border-red-700 rounded text-white" />

        <button id="connectBtn" class="menu-button bg-red-800 border-red-500 hover:bg-red-900">CONNECT & START</button>
        <button id="lobbyBackBtn" class="menu-button bg-gray-600 border-gray-400 hover:bg-gray-700 mt-2">Back to Menu</button>
    </div>

    <!-- In-Game Heads-Up Display (HUD) -->
    <div id="hud" class="hidden">
        <!-- PLAYER 1 (Self) -->
        <div class="topleft flex flex-col items-start gap-1">
            <div id="player-status-title" class="font-bold text-flair">YOU</div>
            <div class="health-bar-container">
                <div id="player-health-bar" class="health-bar" style="width: 100%;">
                    <div id="player-shield-bar" class="shield-bar" style="width: 0%;"></div>
                </div>
            </div>
            <div id="player-hp-text">100 HP</div>
        </div>

        <!-- PLAYER 2 (Opponent / Boss / Teammate) -->
        <div class="topright flex flex-col items-end gap-1">
            <div id="opponent-status-title" class="font-bold text-red-500">OPPONENT</div>
            <div class="health-bar-container" id="opponent-health-container">
                <div id="opponent-health-bar" class="health-bar" style="width: 100%;">
                    <div id="opponent-shield-bar" class="shield-bar" style="width: 0%;"></div>
                </div>
            </div>
            <div id="opponent-hp-text">100 HP / 0 SHD</div>
        </div>

        <!-- Center Message & Timer -->
        <div class="centertop">
            <div id="center-message">WELCOME TO THE ARENA!</div>
            <div id="round-timer" class="text-2xl text-red-500 mt-2"></div>
        </div>

        <!-- Typing Input -->
        <div class="bottomcenter p-4 bg-gray-900 bg-opacity-90 rounded-t-xl border-t-4 border-green-500 shadow-2xl">
            <div class="flex flex-col items-center">
                <div id="target-word" class="text-4xl font-mono mb-2 text-white"></div>
                <input type="text" id="typing-input" class="p-3 text-center text-xl font-mono bg-black text-green-400 border-2 border-green-500 rounded-md w-96 focus:outline-none focus:border-green-300" placeholder="Type the word above..." autocomplete="off" autofocus />
            </div>
        </div>
    </div>

    <!-- Multiplayer Chat Overlay -->
    <div id="multiplayer-overlay" class="hidden">
        <div id="chat-messages"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Type a message..." />
            <button id="chat-send">Send</button>
        </div>
    </div>

</div>

<script type="module">
// =========================================================================
// FIREBASE/GLOBAL VARS (Kept for Canvas Compatibility)
// =========================================================================
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

// =========================================================================
// CORE GAME CONSTANTS, SKINS, AND WORD DICTIONARIES
// =========================================================================

// --- Game Settings ---
const MAX_HEALTH = 100;
const BOSS_HEALTH = 500; // Team mode boss HP
const ROUND_MIN_DURATION = 5000; // 5 seconds
const ROUND_MAX_DURATION = 12000; // 12 seconds
const BASE_ATTACK_DAMAGE = 10;
const BOSS_ATTACK_DAMAGE = 25; // Boss hits harder
const SHIELD_AMOUNT = 20;

// --- Skins Data (Legacy and V2) ---
const ALL_SKINS = [
    // Legacy Skins (Original Script)
    { id: 'default', name: 'Default Skin', icon: 'â—»ï¸', price: 0, equipped: true, type: 'Legacy', complexity: 'V1' },
    { id: 'red', name: 'Crimson Key', icon: 'ðŸ”´', price: 50, equipped: false, type: 'Legacy', complexity: 'V1' },
    { id: 'blue', name: 'Cerulean Core', icon: 'ðŸ”µ', price: 50, equipped: false, type: 'Legacy', complexity: 'V1' },
    { id: 'green', name: 'Emerald Cipher', icon: 'ðŸŸ¢', price: 50, equipped: false, type: 'Legacy', complexity: 'V1' },
    { id: 'yellow', name: 'Golden Glyph', icon: 'ðŸŸ¡', price: 100, equipped: false, type: 'Legacy', complexity: 'V1' },
    { id: 'flame', name: 'Inferno Touch', icon: 'ðŸ”¥', price: 200, equipped: false, type: 'Legacy', complexity: 'V1' },
    { id: 'ice', name: 'Frost Rune', icon: 'ðŸ§Š', price: 200, equipped: false, type: 'Legacy', complexity: 'V1' },
    { id: 'neon', name: 'Neon Arc', icon: 'âš¡', price: 300, equipped: false, type: 'Legacy', complexity: 'V1' },
    { id: 'skull', name: 'Doom Skull', icon: 'ðŸ’€', price: 500, equipped: false, type: 'Legacy', complexity: 'V1' },
    // V2 Skins (More Realistic/Complex)
    { id: 'circuit', name: 'Circuit Board', icon: 'âš™ï¸', price: 800, equipped: false, type: 'V2', complexity: 'V2' },
    { id: 'matrix', name: 'Digital Rain', icon: 'ðŸ’»', price: 1000, equipped: false, type: 'V2', complexity: 'V2' },
    { id: 'crystal', name: 'Aether Crystal', icon: 'ðŸ’Ž', price: 1200, equipped: false, type: 'V2', complexity: 'V2' },
    { id: 'cosmic', name: 'Cosmic Rift', icon: 'ðŸŒŒ', price: 1500, equipped: false, type: 'V2', complexity: 'V2' },
];

// --- Word Dictionary ---
const WORD_DICTIONARY = [
    'attack', 'shield', 'heal', 'blast', 'code', 'type', 'key', 'run', 'fix', 'win',
    'keyboard', 'terminal', 'compiler', 'protocol', 'database', 'executor', 'variable', 'function',
    '#include', '$money', '^power', '&ampersand', '!error', '@user', '%percent', 'Ã±am', 'ÃŸeta', 'â‚¬uro',
];

// =========================================================================
// UTILITY FUNCTIONS (Load/Save Progress)
// =========================================================================

/**
 * Loads player progress (money, owned skins, equipped skin) from localStorage.
 * @returns {object} The player's progress data.
 */
function loadProgress() {
    try {
        const savedProgress = localStorage.getItem('typingTitansProgress');
        if (savedProgress) {
            const progress = JSON.parse(savedProgress);
            // Ensure all skins exist in the progress object for new updates
            ALL_SKINS.forEach(skin => {
                if (!progress.skins.find(s => s.id === skin.id)) {
                    progress.skins.push({ id: skin.id, owned: skin.price === 0 });
                }
            });
            return progress;
        }
    } catch (e) {
        console.error("Error loading progress from localStorage:", e);
    }
    // Default starting progress
    return {
        money: 50, // Starting money for new players
        equippedSkinId: 'default',
        skins: ALL_SKINS.map(s => ({
            id: s.id,
            owned: s.price === 0, // Only default skins are owned initially
        }))
    };
}

/**
 * Saves player progress to localStorage.
 * @param {object} progress - The player's current progress data.
 */
function saveProgress(progress) {
    try {
        localStorage.setItem('typingTitansProgress', JSON.stringify(progress));
    } catch (e) {
        console.error("Error saving progress to localStorage:", e);
    }
}

// =========================================================================
// WEBRTC MANAGER CLASS (Real-time Multiplayer)
// =========================================================================

/**
 * Manages WebRTC peer connections and data channels for 1v1 multiplayer.
 */
class WebRTCManager {
    constructor(gameInstance) {
        this.game = gameInstance;
        this.peerConnection = null;
        this.dataChannel = null;
        this.localId = crypto.randomUUID(); // Unique ID for peer identification
        this.isInitiator = false;
        this.isConnected = false;

        // Configuration for STUN servers
        this.rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };
    }

    /**
     * Initializes the WebRTC connection, setting up the PeerConnection and event handlers.
     */
    initializeConnection() {
        this.peerConnection = new RTCPeerConnection(this.rtcConfig);
        this.peerConnection.onicecandidate = this.handleIceCandidate.bind(this);
        this.peerConnection.ondatachannel = this.handleDataChannelCreation.bind(this);
        this.peerConnection.oniceconnectionstatechange = this.handleIceConnectionStateChange.bind(this);
        this.peerConnection.onconnectionstatechange = this.handleConnectionStateChange.bind(this);
    }

    /**
     * Handles ICE candidate discovery and sends it to the remote peer (via mock signaling).
     */
    handleIceCandidate(event) {
        if (event.candidate) {
            this.sendSignal({
                type: 'candidate',
                candidate: event.candidate,
                senderId: this.localId
            });
            console.debug("WebRTC: Sent ICE candidate.");
        }
    }
    
    /**
     * Handles changes in the ICE connection state.
     */
    handleIceConnectionStateChange() {
        console.log('WebRTC ICE Connection State:', this.peerConnection.iceConnectionState);
        if (this.peerConnection.iceConnectionState === 'failed' || this.peerConnection.iceConnectionState === 'disconnected') {
            if (this.isConnected) {
                this.handleDataChannelClose();
            }
        }
    }

    /**
     * Handles changes in the overall connection state.
     */
    handleConnectionStateChange() {
        console.log('WebRTC Connection State:', this.peerConnection.connectionState);
        if (this.peerConnection.connectionState === 'closed' || this.peerConnection.connectionState === 'failed') {
             if (this.isConnected) {
                this.handleDataChannelClose();
            }
        }
    }


    /**
     * Handles the creation of the DataChannel when the remote peer initiates it.
     */
    handleDataChannelCreation(event) {
        this.dataChannel = event.channel;
        this.setupDataChannelHandlers();
        console.log("WebRTC: DataChannel received and setup by remote peer.");
    }

    /**
     * Sets up event listeners for the DataChannel (open, close, message).
     */
    setupDataChannelHandlers() {
        this.dataChannel.onopen = this.handleDataChannelOpen.bind(this);
        this.dataChannel.onclose = this.handleDataChannelClose.bind(this);
        this.dataChannel.onmessage = this.handleDataChannelMessage.bind(this);
        this.dataChannel.onerror = (error) => console.error("WebRTC DataChannel Error:", error);
    }

    /**
     * Handles DataChannel open event, signaling a successful connection.
     */
    handleDataChannelOpen() {
        this.isConnected = true;
        this.game.setMultiplayerState(true);
        this.game.showCenterMessage("CONNECTION ESTABLISHED. STARTING ARENA!", '#0f0', 3000);
        this.game.startRound();
        this.updateStatus('Connected', 'text-success');
        console.log("WebRTC: DataChannel opened. Connection is active.");
    }

    /**
     * Handles DataChannel message events, parsing and processing game updates/chats.
     */
    handleDataChannelMessage(event) {
        try {
            const data = JSON.parse(event.data);
            if (data.type === 'game_state') {
                // Used for 1v1 duel: Opponent state
                this.game.receiveOpponentState(data.state);
            } else if (data.type === 'player_state') {
                // Used for Team Mode: Teammate state
                this.game.receiveTeammateState(data.state);
            } else if (data.type === 'boss_attack') {
                // Used for Team Mode: Boss attack on US
                this.game.receiveBossAttack(data.damage);
            } else if (data.type === 'chat') {
                this.game.addChatMessage('Teammate', data.message, '#0ff');
            } else if (data.type === 'round_start') {
                // Synchronize round with initiator's state
                this.game.startRound(data.word);
            } else if (data.type === 'boss_state') {
                 // Used for Team Mode: Boss state
                this.game.receiveBossState(data.state);
            }
        } catch (e) {
            console.warn("WebRTC: Failed to parse incoming message:", event.data, e);
        }
    }

    /**
     * Handles DataChannel close event, indicating connection loss.
     */
    handleDataChannelClose() {
        this.isConnected = false;
        this.game.setMultiplayerState(false);
        this.game.showCenterMessage("PEER DISCONNECTED. RETURNING TO LOBBY.", '#f00', 5000);
        this.game.returnToLobby();
        this.updateStatus('Disconnected', 'text-error');
        console.log("WebRTC: DataChannel closed.");
    }

    /**
     * Initiates the connection by creating the DataChannel and Offer (Peer A).
     * @param {string} remoteId - The Peer ID of the opponent. (Unused in mock)
     */
    async createOffer(remoteId) {
        this.isInitiator = true;
        this.initializeConnection();
        this.dataChannel = this.peerConnection.createDataChannel("gameChannel");
        this.setupDataChannelHandlers();

        try {
            const offer = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(offer);
            this.sendSignal({
                type: 'offer',
                sdp: this.peerConnection.localDescription,
                senderId: this.localId,
                targetId: remoteId
            });
            this.updateStatus('Waiting for opponent...', 'text-flair');
            console.log("WebRTC: Created and sent offer.");
        } catch (error) {
            console.error("WebRTC: Error creating offer:", error);
            this.updateStatus('Error creating offer', 'text-error');
        }
    }

    /**
     * Processes an incoming offer and sends an Answer (Peer B).
     */
    async handleOffer(offer, remoteId) {
        this.isInitiator = false;
        this.initializeConnection();

        try {
            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(answer);
            this.sendSignal({
                type: 'answer',
                sdp: this.peerConnection.localDescription,
                senderId: this.localId,
                targetId: remoteId
            });
            this.updateStatus('Sent answer, connecting...', 'text-flair');
            console.log("WebRTC: Handled offer and sent answer.");
        } catch (error) {
            console.error("WebRTC: Error handling offer:", error);
            this.updateStatus('Error handling offer', 'text-error');
        }
    }

    /**
     * Processes an incoming answer. (Peer A)
     */
    async handleAnswer(answer) {
        try {
            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            this.updateStatus('Answer received, connecting...', 'text-flair');
            console.log("WebRTC: Handled answer.");
        } catch (error) {
            console.error("WebRTC: Error handling answer:", error);
            this.updateStatus('Error handling answer', 'text-error');
        }
    }

    /**
     * Processes an incoming ICE candidate.
     */
    async handleCandidate(candidate) {
        try {
            if (candidate) {
                await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                console.debug("WebRTC: Added remote ICE candidate.");
            }
        } catch (error) {
            console.error("WebRTC: Error adding remote candidate:", error);
        }
    }

    /**
     * Sends a message over the DataChannel if connected.
     */
    send(data) {
        if (this.isConnected && this.dataChannel && this.dataChannel.readyState === 'open') {
            try {
                this.dataChannel.send(JSON.stringify(data));
            } catch (e) {
                console.warn("WebRTC: Failed to send data:", e);
            }
        }
    }

    /**
     * MOCK: Simulates sending a signal (offer, answer, candidate) through a server.
     */
    sendSignal(signal) {
        // --- NOTE: This is the MOCK of the signaling server logic ---
        console.log(`WebRTC MOCK: Sending signal to ${signal.targetId || 'unknown'}: ${signal.type}`);

        const signalQueue = document.getElementById('local-peer-id');
        if (signal.type === 'offer' || signal.type === 'answer') {
            // Put the entire SDP into the local ID box for manual copy/paste exchange
            signalQueue.value = JSON.stringify({
                type: signal.type,
                sdp: signal.sdp,
                senderId: signal.senderId,
                mode: this.game.matchMode, // Crucial for connection handshake
            });
        }
    }

    /**
     * MOCK: Updates the status text in the multiplayer lobby UI.
     */
    updateStatus(text, className = 'text-gray-400') {
        const statusEl = document.getElementById('rtc-status');
        if (statusEl) {
            statusEl.innerHTML = `Status: <span class="${className}">${text}</span>`;
        }
    }

    /**
     * Resets the entire WebRTC connection state.
     */
    close() {
        if (this.dataChannel) {
            this.dataChannel.close();
        }
        if (this.peerConnection) {
            this.peerConnection.close();
        }
        this.peerConnection = null;
        this.dataChannel = null;
        this.isConnected = false;
        this.isInitiator = false;
        this.updateStatus('Idle', 'text-flair');
        console.log("WebRTC: Connection closed and reset.");
    }
}

// =========================================================================
// PLAYER AND GAME CLASSES (New Architecture)
// =========================================================================

/**
 * Represents a Player's state (Local or Opponent).
 */
class Player {
    /**
     * @param {string} id - 'local', 'opponent', 'teammate', or 'boss'
     * @param {number} [maxHp=MAX_HEALTH] - Optional starting HP.
     */
    constructor(id, maxHp = MAX_HEALTH) {
        this.id = id;
        this.maxHp = maxHp;
        this.hp = maxHp;
        this.shield = 0;
        this.dead = false;
    }

    /**
     * Applies damage, factoring in shield before health.
     * @param {number} amount - Damage amount.
     */
    takeDamage(amount) {
        if (this.dead) return;

        let remainingDamage = amount;
        if (this.shield > 0) {
            const shieldAbsorbed = Math.min(this.shield, remainingDamage);
            this.shield -= shieldAbsorbed;
            remainingDamage -= shieldAbsorbed;
        }

        if (remainingDamage > 0) {
            this.hp -= remainingDamage;
        }

        if (this.hp <= 0) {
            this.hp = 0;
            this.dead = true;
        }
    }

    /**
     * Adds shield protection.
     * @param {number} amount - Shield amount.
     */
    gainShield(amount) {
        this.shield = Math.min(amount, this.maxHp / 2); // Max shield is 50% of max HP
    }

    /**
     * Heals the player.
     * @param {number} amount - Heal amount.
     */
    heal(amount) {
        this.hp = Math.min(this.maxHp, this.hp + amount);
    }

    /**
     * Resets the player state for a new match.
     */
    reset(newMaxHp = MAX_HEALTH) {
        this.maxHp = newMaxHp;
        this.hp = newMaxHp;
        this.shield = 0;
        this.dead = false;
    }
}

/**
 * Manages the core game loop, state, and UI.
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.localPlayer = new Player('local');
        this.remoteEntity = new Player('opponent'); // Can be opponent, teammate, or boss
        this.progress = loadProgress();
        this.money = this.progress.money;
        this.equippedSkin = ALL_SKINS.find(s => s.id === this.progress.equippedSkinId);

        this.rtcManager = new WebRTCManager(this);
        this.isMultiplayer = false;
        this.gameRunning = false;
        this.matchMode = 'solo'; // 'solo', 'duel_mp', 'team_mp'
        this.nextBossAttackTarget = 'local'; // For team mode, tracks who the Boss attacks next

        // Typing State
        this.targetWord = '';
        this.typedWord = '';
        this.wordStartTime = 0;
        this.roundTimerId = null;
        this.bossAttackIntervalId = null;

        // UI Elements
        this.ui = {
            menu: document.getElementById('menu'),
            shop: document.getElementById('shop'),
            lobby: document.getElementById('multiplayer-lobby'),
            hud: document.getElementById('hud'),
            typingInput: document.getElementById('typing-input'),
            targetWordEl: document.getElementById('target-word'),
            centerMessage: document.getElementById('center-message'),
            roundTimer: document.getElementById('round-timer'),
            chatInput: document.getElementById('chat-input'),
            chatMessages: document.getElementById('chat-messages'),
            chatSendBtn: document.getElementById('chat-send'),
            // HP Bars
            playerTitle: document.getElementById('player-status-title'),
            opponentTitle: document.getElementById('opponent-status-title'),
            opponentHealthContainer: document.getElementById('opponent-health-container'),
        };

        this.initCanvas();
        this.initEventListeners();
        this.updateShopUI(); // This call is now safe
    }

    /**
     * Shows a temporary popup message on the screen.
     * @param {string} text - The message to display.
     * @param {string} color - CSS color string.
     * @param {number} duration - Duration in milliseconds.
     */
    showPopup(text, color = '#fff', duration = 1500) {
        const popup = document.createElement('div');
        popup.textContent = text;
        popup.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background: rgba(0, 0, 0, 0.9);
            color: ${color};
            border: 2px solid ${color};
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
        `;
        document.body.appendChild(popup);

        // Fade in
        setTimeout(() => {
            popup.style.opacity = '1';
            popup.style.transform = 'translate(-50%, -50%) scale(1.05)';
        }, 10);

        // Fade out and remove
        setTimeout(() => {
            popup.style.opacity = '0';
            popup.style.transform = 'translate(-50%, -50%) scale(0.95)';
            setTimeout(() => popup.remove(), 300);
        }, duration);
    }

    /**
     * Initializes the canvas size and drawing context.
     */
    initCanvas() {
        this.resizeCanvas();
        window.addEventListener('resize', this.resizeCanvas.bind(this));
    }

    /**
     * Adjusts the canvas size to fill the viewport.
     */
    resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    /**
     * Initializes all event listeners for UI buttons and input.
     */
    initEventListeners() {
        // --- Menu Buttons ---
        document.getElementById('precodedBtn').onclick = () => this.startGame('solo', 'V1');
        document.getElementById('precodedUniBtn').onclick = () => this.startGame('solo', 'V2');
        document.getElementById('multiplayerDuelBtn').onclick = () => this.showMultiplayerLobby('duel_mp'); // 1v1 DUEL
        document.getElementById('multiplayerTeamBtn').onclick = () => this.showMultiplayerLobby('team_mp'); // 2v1 TEAM
        document.getElementById('skinsShopBtn').onclick = () => this.showSkinsShop();

        // --- Shop Buttons ---
        document.getElementById('shopBackBtn').onclick = () => this.showMenu();
        document.getElementById('skin-grid').onclick = (e) => {
            const item = e.target.closest('.skin-item');
            if (item) {
                this.handleSkinPurchaseEquip(item.dataset.id);
            }
        };

        // --- Multiplayer Lobby Buttons ---
        document.getElementById('lobbyBackBtn').onclick = () => this.showMenu();
        document.getElementById('connectBtn').onclick = () => this.connectWebRTC();

        // --- In-Game Input and Chat ---
        this.ui.typingInput.oninput = this.handleTypingInput.bind(this);
        this.ui.typingInput.onkeydown = this.handleTypingKeyDown.bind(this);
        this.ui.chatSendBtn.onclick = this.sendChatMessage.bind(this);
        this.ui.chatInput.onkeydown = (e) => {
            if (e.key === 'Enter') this.sendChatMessage();
        };

        // --- Global Key Handlers (for restart 'R') ---
        document.addEventListener('keydown', e => {
            if (e.key === 'r' || e.key === 'R') {
                if (this.localPlayer.dead || this.remoteEntity.dead) {
                    this.localPlayer.reset();
                    this.remoteEntity.reset(this.matchMode === 'team_mp' ? BOSS_HEALTH : MAX_HEALTH);
                    this.startRound();
                    this.showCenterMessage("RESTARTING MATCH!", '#ff0', 1000);
                }
            }
        });
    }

    /**
     * Handles key presses in the typing input field.
     */
    handleTypingKeyDown(e) {
        const input = this.ui.typingInput;

        // Block all non-text keys in the input area during a round
        if (!this.gameRunning || this.localPlayer.dead) {
            e.preventDefault();
            return;
        }

        // Allow backspace
        if (e.key === 'Backspace') return;

        // Check for correct character input (key-specific attack system)
        if (e.key.length === 1) {
            this.handleKeyAttack(e.key);
        }

        // Check for word submission
        if (e.key === 'Enter') {
            e.preventDefault(); // Prevent new line
            if (input.value.trim() === this.targetWord) {
                this.processWordCompletion();
                input.value = '';
            } else {
                this.showPopup("Incorrect word!", '#f00');
            }
        }
    }

    /**
     * Handles the 'input' event to update the typed word.
     */
    handleTypingInput() {
        this.typedWord = this.ui.typingInput.value;
    }

    /**
     * Processes a key press, triggering a minor, key-specific action.
     */
    handleKeyAttack(key) {
        const charCode = key.charCodeAt(0);
        const effectMagnitude = (charCode % 5) + 1; // 1 to 5 damage/effect

        // Use the character itself to determine the action type
        if (/[a-z]/i.test(key)) { // Letters: Minor damage boost
            if (this.matchMode === 'duel_mp' || this.matchMode === 'solo') {
                this.remoteEntity.takeDamage(1);
            }
        } else if (/[0-9]/.test(key)) { // Numbers: Minor shield boost
            this.localPlayer.gainShield(effectMagnitude * 0.5);
        } else if (/[!@#$%^&*()_+\-=[\]{};':"\\|,.<>/?~`]/.test(key)) { // Symbols: Minor slow on opponent (visual only in solo)
            this.showPopup(`Symbolic Interference: ${key}`, '#f8f', 500);
        } else { // Unicode/Other: Very minor health bump
            this.localPlayer.heal(0.5);
        }

        // Only send updates if in a multiplayer mode
        if (this.isMultiplayer) {
            this.sendLocalState();
        }
    }

    /**
     * Executes the main action upon successful word completion.
     */
    processWordCompletion() {
        const timeTaken = Date.now() - this.wordStartTime;
        const baseDamage = BASE_ATTACK_DAMAGE;
        const speedBonus = timeTaken < 3000 ? 5 : 0; // Bonus for typing in under 3 seconds
        const entityToHit = this.remoteEntity;

        // Determine action based on the word
        let action = 'ATTACK';
        let effectColor = '#f00';
        let actionMessage = `HIT! -${baseDamage} HP`;
        let totalDamage = baseDamage + speedBonus;

        if (this.targetWord === 'shield') {
            this.localPlayer.gainShield(SHIELD_AMOUNT);
            action = 'SHIELD';
            effectColor = '#0bf';
            actionMessage = `SHIELD GAINED! +${SHIELD_AMOUNT} SHD`;
            totalDamage = 0;
        } else if (this.targetWord === 'heal') {
            this.localPlayer.heal(SHIELD_AMOUNT);
            action = 'HEAL';
            effectColor = '#0f0';
            actionMessage = `HEALED! +${SHIELD_AMOUNT} HP`;
            totalDamage = 0;
        } else {
            // Default attack
            entityToHit.takeDamage(totalDamage);
            actionMessage = `CRITICAL ATTACK! -${totalDamage} HP`;
        }

        // Reward money based on word length
        const moneyReward = Math.ceil(this.targetWord.length / 2);
        this.money += moneyReward;
        this.saveState();

        this.showPopup(`${actionMessage} (+${moneyReward} Gold)`, effectColor);

        // Send state updates
        if (this.isMultiplayer) {
            this.sendLocalState();
            // In Team Mode, we also need to send the Boss's new state
            if (this.matchMode === 'team_mp' && entityToHit.id === 'boss') {
                this.sendBossState();
            }
        }

        if (!entityToHit.dead) {
            this.startRound();
        } else {
            // Check win condition
            const won = (this.matchMode === 'duel_mp' || this.matchMode === 'solo') ? entityToHit.dead : true;
            this.endMatch(won);
        }
    }

    /**
     * Starts the game loop and hides menus.
     * @param {string} mode - 'solo', 'duel_mp', or 'team_mp'.
     * @param {string} type - 'V1' or 'V2' (for solo word type).
     */
    startGame(mode, type) {
        this.matchMode = mode;
        this.wordType = type;
        this.gameRunning = true;
        this.localPlayer.reset();

        // Configure the remote entity based on mode
        let remoteMaxHp = MAX_HEALTH;
        let remoteIcon = 'ENEMY';
        let remoteTitle = 'OPPONENT';
        let healthBarClass = '';

        if (mode === 'team_mp') {
            remoteMaxHp = BOSS_HEALTH;
            remoteIcon = 'ðŸ‘¾';
            remoteTitle = 'BOSS (Teammate HP Below)';
            healthBarClass = 'health-boss';
            this.startBossAttackLoop();
        } else if (mode === 'duel_mp') {
            remoteIcon = 'DUELIST';
            remoteTitle = 'OPPONENT';
            this.stopBossAttackLoop();
        } else { // solo
            remoteIcon = 'AI';
            remoteTitle = 'AI OPPONENT';
            this.stopBossAttackLoop();
            // Start a simple solo AI loop (just to have them heal sometimes)
            this.soloAILoop = setInterval(() => {
                if (Math.random() < 0.2 && !this.remoteEntity.dead) { // 20% chance to heal/shield
                    this.remoteEntity.gainShield(10);
                    this.showCenterMessage("AI SHIELDING!", '#f0f', 500);
                }
            }, 3000);
        }

        this.remoteEntity.reset(remoteMaxHp);
        this.remoteEntity.id = mode === 'team_mp' ? 'boss' : (mode === 'duel_mp' ? 'teammate' : 'opponent');

        // Update UI status/styles
        this.ui.opponentTitle.textContent = remoteTitle;
        this.ui.opponentHealthContainer.className = `health-bar-container ${healthBarClass}`;

        // Hide all panels, show HUD
        this.ui.menu.classList.add('hidden');
        this.ui.shop.classList.add('hidden');
        this.ui.lobby.classList.add('hidden');
        this.ui.hud.classList.remove('hidden');
        this.ui.typingInput.focus();

        // Show chat only if multiplayer
        if (mode.includes('_mp')) {
            document.getElementById('multiplayer-overlay').classList.remove('hidden');
        } else {
            document.getElementById('multiplayer-overlay').classList.add('hidden');
        }

        this.showCenterMessage("DUEL START!", '#ffeb3b', 2000);
        this.startRound();
    }

    /**
     * Boss AI logic for Team Mode. Initiator handles the attack timing and target.
     */
    startBossAttackLoop() {
        if (!this.rtcManager.isInitiator || this.bossAttackIntervalId) return;

        this.bossAttackIntervalId = setInterval(() => {
            if (!this.gameRunning || this.localPlayer.dead || this.remoteEntity.dead) {
                this.stopBossAttackLoop();
                return;
            }

            // Boss attacks one of the two players (local or remote)
            const target = this.nextBossAttackTarget;
            const damage = BOSS_ATTACK_DAMAGE + Math.floor(Math.random() * 10); // Variable damage

            if (target === 'local') {
                this.localPlayer.takeDamage(damage);
                this.showPopup(`BOSS HIT YOU! -${damage} HP`, '#f00', 1500);
                this.sendLocalState();
                this.nextBossAttackTarget = 'remote'; // Switch target
            } else {
                // Tell the remote player they got hit
                this.rtcManager.send({ type: 'boss_attack', damage });
                this.showCenterMessage("BOSS ATTACKED TEAMMATE!", '#ff0', 1500);
                this.nextBossAttackTarget = 'local'; // Switch target
            }

            // Check if local player died
            if (this.localPlayer.dead) {
                this.endMatch(false);
            }
        }, 5000); // Boss attacks every 5 seconds
    }

    /**
     * Stops the Boss AI attack loop.
     */
    stopBossAttackLoop() {
        if (this.bossAttackIntervalId) {
            clearInterval(this.bossAttackIntervalId);
            this.bossAttackIntervalId = null;
        }
        if (this.soloAILoop) {
            clearInterval(this.soloAILoop);
            this.soloAILoop = null;
        }
    }

    /**
     * Starts a new round by selecting a word and setting a timer.
     * @param {string} [fixedWord=null] - Optional word for MP synchronization.
     */
    startRound(fixedWord = null) {
        if (this.roundTimerId) {
            clearTimeout(this.roundTimerId);
        }
        if (this.localPlayer.dead || this.remoteEntity.dead) {
            this.endMatch(this.localPlayer.dead ? false : true);
            return;
        }

        // Select a new word
        if (fixedWord) {
            this.targetWord = fixedWord;
        } else {
            // Filter words based on complexity for solo mode
            let pool = WORD_DICTIONARY.filter(word => {
                const hasUnicode = !/^[a-zA-Z0-9]+$/.test(word);
                return this.wordType === 'V2' ? true : !hasUnicode;
            });
            this.targetWord = pool[Math.floor(Math.random() * pool.length)];

            // Send round synchronization to opponent if MP and initiator
            if (this.isMultiplayer && this.rtcManager.isInitiator) {
                this.rtcManager.send({ type: 'round_start', word: this.targetWord });
            }
        }

        this.ui.targetWordEl.textContent = this.targetWord;
        this.ui.typingInput.value = '';
        this.typedWord = '';
        this.wordStartTime = Date.now();

        // Set round timer (5s to 12s)
        const duration = Math.floor(Math.random() * (ROUND_MAX_DURATION - ROUND_MIN_DURATION + 1)) + ROUND_MIN_DURATION;
        let timeRemaining = Math.floor(duration / 1000);
        this.ui.roundTimer.textContent = `${timeRemaining}s`;

        // Update timer every second
        const intervalId = setInterval(() => {
            timeRemaining--;
            this.ui.roundTimer.textContent = `${timeRemaining}s`;

            if (timeRemaining <= 0) {
                clearInterval(intervalId);
                // Round fails, small penalty
                this.localPlayer.takeDamage(BASE_ATTACK_DAMAGE / 2);
                this.showPopup('TIME OUT! -5 HP Penalty.', '#ffa07a', 1500);
                if (this.isMultiplayer) this.sendLocalState();
                this.startRound();
            }
        }, 1000);

        this.roundTimerId = intervalId;
    }

    /**
     * Ends the current match and shows the winner/loser screen.
     */
    endMatch(won) {
        this.gameRunning = false;
        this.stopBossAttackLoop();
        if (this.roundTimerId) {
            clearInterval(this.roundTimerId);
        }

        const message = won ? "VICTORY! +100 Gold Reward." : "DEFEAT! Try again.";
        const color = won ? '#0f0' : '#f00';
        this.showCenterMessage(message, color, 5000);

        if (won) {
            this.money += 100; // Match win bonus
        }
        this.saveState();

        setTimeout(() => this.returnToLobby(), 5000);
    }

    /**
     * Renders the game state on the canvas and HUD.
     */
    render() {
        // Clear canvas
        this.ctx.fillStyle = '#0a0a0a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (!this.gameRunning) {
            return;
        }

        // Draw Player 1 (Local) and Player 2 (Remote Entity)
        this.drawPlayer(this.localPlayer, this.canvas.width / 4, this.canvas.height / 2, this.equippedSkin.icon, '#0f0');
        this.drawPlayer(this.remoteEntity, this.canvas.width * 3 / 4, this.canvas.height / 2, this.getRemoteIcon(), this.getRemoteColor());

        // Draw HUD updates
        this.updateHUD();
    }

    /**
     * Gets the appropriate icon for the remote entity based on mode.
     */
    getRemoteIcon() {
        if (this.matchMode === 'team_mp') return 'ðŸ‘¾';
        if (this.matchMode === 'duel_mp') return 'DUELIST';
        return 'AI';
    }

    /**
     * Gets the appropriate color for the remote entity based on mode.
     */
    getRemoteColor() {
        if (this.matchMode === 'team_mp') return '#ff0000'; // Boss is red
        if (this.matchMode === 'duel_mp') return '#00ffff'; // Opponent is cyan
        return '#ffeb3b'; // Solo AI is yellow
    }

    /**
     * Draws a player's avatar on the canvas.
     */
    drawPlayer(player, x, y, icon, color) {
        this.ctx.save();
        this.ctx.translate(x, y);

        // Body outline/glow
        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = color;
        this.ctx.fillStyle = color;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 40, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;

        // Draw Icon/Skin
        this.ctx.fillStyle = '#000';
        this.ctx.font = '48px Inter';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(icon, 0, 0);

        // Draw status (Dead)
        if (player.dead) {
            this.ctx.font = '24px Inter';
            this.ctx.fillStyle = '#f00';
            this.ctx.fillText('DEAD', 0, 70);
        }

        this.ctx.restore();
    }

    /**
     * Updates the HUD elements (HP, Shields).
     */
    updateHUD() {
        // Local Player HUD
        const localPercent = this.localPlayer.hp / this.localPlayer.maxHp * 100;
        const localShieldPercent = this.localPlayer.shield / (this.localPlayer.maxHp / 2) * 100;
        document.getElementById('player-health-bar').style.width = `${localPercent}%`;
        document.getElementById('player-shield-bar').style.width = `${localShieldPercent}%`;
        document.getElementById('player-hp-text').textContent = `${Math.ceil(this.localPlayer.hp)} HP / ${Math.ceil(this.localPlayer.shield)} SHD`;

        // Remote Entity HUD (Opponent/Boss/Teammate)
        const remotePercent = this.remoteEntity.hp / this.remoteEntity.maxHp * 100;
        const remoteShieldPercent = this.remoteEntity.shield / (this.remoteEntity.maxHp / 2) * 100;
        document.getElementById('opponent-health-bar').style.width = `${remotePercent}%`;
        document.getElementById('opponent-shield-bar').style.width = `${remoteShieldPercent}%`;

        let remoteText = '';
        if (this.matchMode === 'team_mp') {
            remoteText = `BOSS: ${Math.ceil(this.remoteEntity.hp)} HP / TMMT: ${Math.ceil(this.remoteTeammate?.hp || 100)} HP`;
        } else if (this.matchMode === 'duel_mp') {
            remoteText = `OPPONENT: ${Math.ceil(this.remoteEntity.hp)} HP / ${Math.ceil(this.remoteEntity.shield)} SHD`;
        } else {
            remoteText = `AI: ${Math.ceil(this.remoteEntity.hp)} HP / ${Math.ceil(this.remoteEntity.shield)} SHD`;
        }
        document.getElementById('opponent-hp-text').textContent = remoteText;
    }

    /**
     * Updates the center message on the HUD.
     */
    showCenterMessage(message, color, duration = 1500) {
        const el = this.ui.centerMessage;
        el.textContent = message;
        el.style.color = color;
        el.style.textShadow = `0 0 10px ${color}`;
        if (this.centerMessageTimeout) {
            clearTimeout(this.centerMessageTimeout);
        }
        this.centerMessageTimeout = setTimeout(() => {
            el.textContent = "TYPING TITANS: KEYBOARD ARENA";
            el.style.color = '#ffeb3b';
            el.style.textShadow = '0 0 8px #ffeb3b';
        }, duration);
    }

    /**
     * Saves current money and skin data to localStorage.
     */
    saveState() {
        this.progress.money = this.money;
        this.progress.equippedSkinId = this.equippedSkin.id;
        saveProgress(this.progress);
        this.updateShopUI(); // Update UI after saving
    }

    // --- UI/Panel Management ---

    /**
     * Hides all panels and shows the main menu.
     */
    showMenu() {
        this.gameRunning = false;
        this.stopBossAttackLoop();
        if (this.roundTimerId) {
            clearInterval(this.roundTimerId);
        }
        this.rtcManager.close(); // Close any active RTC connection
        this.ui.hud.classList.add('hidden');
        document.getElementById('multiplayer-overlay').classList.add('hidden');
        this.ui.shop.classList.add('hidden');
        this.ui.lobby.classList.add('hidden');
        this.ui.menu.classList.remove('hidden');
    }

    /**
     * Shows the skins shop UI.
     */
    showSkinsShop() {
        this.ui.menu.classList.add('hidden');
        this.ui.lobby.classList.add('hidden');
        this.ui.shop.classList.remove('hidden');
        this.updateShopUI();
    }

    /**
     * Updates the skins shop display based on player progress.
     */
    updateShopUI() {
        document.getElementById('playerMoney').textContent = this.money;
        const skinGrid = document.getElementById('skin-grid');
        skinGrid.innerHTML = '';

        ALL_SKINS.forEach(skin => {
            const playerSkinData = this.progress.skins.find(s => s.id === skin.id);
            const isOwned = playerSkinData ? playerSkinData.owned : false;
            const isEquipped = this.equippedSkin.id === skin.id;

            const statusText = isEquipped ? 'EQUIPPED' : (isOwned ? 'OWNED' : `${skin.price} GOLD`);
            const statusClass = isEquipped ? 'text-success' : (isOwned ? 'text-flair' : 'text-yellow-400');
            const itemClass = isEquipped ? 'equipped' : (isOwned ? 'owned' : 'locked');

            const itemHTML = `
                <div class="skin-item ${itemClass}" data-id="${skin.id}">
                    <div class="skin-preview">${skin.icon}</div>
                    <div class="skin-name">${skin.name}</div>
                    <div class="${statusClass}">${statusText}</div>
                </div>
            `;
            skinGrid.innerHTML += itemHTML;
        });
    }

    /**
     * Handles purchase or equipping of a skin.
     */
    handleSkinPurchaseEquip(skinId) {
        const skin = ALL_SKINS.find(s => s.id === skinId);
        if (!skin) return;

        const playerSkinData = this.progress.skins.find(s => s.id === skinId);
        const isOwned = playerSkinData ? playerSkinData.owned : false;

        if (isOwned) {
            // Equip
            this.equippedSkin = skin;
            this.progress.equippedSkinId = skinId;
            this.saveState();
            this.showPopup(`${skin.name} Equipped!`, '#0ff');
        } else {
            // Buy
            if (this.money >= skin.price) {
                this.money -= skin.price;
                if (playerSkinData) {
                    playerSkinData.owned = true;
                } else {
                    this.progress.skins.push({ id: skinId, owned: true });
                }
                this.equippedSkin = skin; // Equip immediately upon purchase
                this.progress.equippedSkinId = skinId;
                this.saveState();
                this.showPopup(`Purchased & Equipped ${skin.name}!`, '#0f0');
            } else {
                this.showPopup('Not enough Gold!', '#f00');
            }
        }
    }

    /**
     * Displays the WebRTC lobby UI.
     * @param {string} mode - The intended multiplayer mode ('duel_mp' or 'team_mp').
     */
    showMultiplayerLobby(mode) {
        this.matchMode = mode;
        this.ui.menu.classList.add('hidden');
        this.ui.shop.classList.add('hidden');
        this.ui.lobby.classList.remove('hidden');

        document.getElementById('lobby-title').textContent = mode === 'duel_mp' ? '1V1 DUEL LOBBY' : '2V1 TEAM LOBBY';
        document.getElementById('lobby-description').textContent = mode === 'duel_mp' ?
            'Connect for a direct 1v1 battle, damaging your opponent directly.' :
            'Connect with a teammate to fight a powerful AI Boss!';

        // Reset and get local ID
        this.rtcManager.close();
        document.getElementById('local-peer-id').value = this.rtcManager.localId;
        document.getElementById('remote-peer-id').value = '';
    }

    // --- Multiplayer Management ---

    /**
     * Initiates the WebRTC connection process.
     */
    async connectWebRTC() {
        const remoteInput = document.getElementById('remote-peer-id').value.trim();
        const localIdInput = document.getElementById('local-peer-id');

        if (!remoteInput) {
            this.rtcManager.updateStatus('Error: Paste opponent ID/Signal!', 'text-error');
            return;
        }

        this.rtcManager.updateStatus('Connecting...', 'text-flair');
        localIdInput.value = 'Waiting for SDP exchange...'; // Clear ID to show SDP

        let signal;
        try {
            signal = JSON.parse(remoteInput);
        } catch (e) {
            // Treat as a regular ID and create an offer
            this.rtcManager.createOffer(remoteInput);
            return;
        }

        // If it's a signal, process it
        if (signal.type === 'offer') {
            // Crucial check: Ensure modes match before processing
            if (signal.mode !== this.matchMode) {
                this.rtcManager.updateStatus(`Error: Mode mismatch! (${signal.mode} vs ${this.matchMode})`, 'text-error');
                return;
            }
            await this.rtcManager.handleOffer(signal.sdp, signal.senderId);
        } else if (signal.type === 'answer') {
            await this.rtcManager.handleAnswer(signal.sdp);
        } else if (signal.type === 'candidate') {
            await this.rtcManager.handleCandidate(signal.candidate);
        } else {
            this.rtcManager.updateStatus('Invalid signal/ID format.', 'text-error');
        }
    }

    /**
     * Sets the multiplayer flag and adjusts the game mode.
     */
    setMultiplayerState(isConnected) {
        this.isMultiplayer = isConnected;
        if (isConnected) {
            this.startGame(this.matchMode, 'V2'); // Start game in the selected mode
        }
    }

    // --- State Sending (Split for Duel vs. Team) ---

    /**
     * Sends the local player's state to the peer.
     * In DUEL mode: this is the state of the opponent.
     * In TEAM mode: this is the state of the teammate.
     */
    sendLocalState() {
        const state = {
            hp: this.localPlayer.hp,
            shield: this.localPlayer.shield,
            dead: this.localPlayer.dead,
        };
        const type = this.matchMode === 'duel_mp' ? 'game_state' : 'player_state';
        this.rtcManager.send({ type, state });
    }

    /**
     * Sends the Boss's state to the teammate (only in Team Mode).
     */
    sendBossState() {
        if (this.matchMode === 'team_mp' && this.remoteEntity.id === 'boss') {
            const state = {
                hp: this.remoteEntity.hp,
                dead: this.remoteEntity.dead,
            };
            this.rtcManager.send({ type: 'boss_state', state });
        }
    }

    // --- State Receiving (Split for Duel vs. Team) ---

    /**
     * Receives and applies the opponent's game state (DUEL mode).
     * The remote state is mapped to our local 'remoteEntity'.
     */
    receiveOpponentState(state) {
        if (this.matchMode !== 'duel_mp') return;
        this.remoteEntity.hp = state.hp;
        this.remoteEntity.shield = state.shield;
        this.remoteEntity.dead = state.dead;

        if (this.remoteEntity.dead) {
            this.endMatch(true); // Opponent is dead, I win
        }
    }

    /**
     * Receives and applies the teammate's game state (TEAM mode).
     * We track the teammate's state separately.
     */
    receiveTeammateState(state) {
        if (this.matchMode !== 'team_mp') return;
        // Store teammate state for HUD update
        this.remoteTeammate = state;

        if (state.dead && this.localPlayer.dead) {
            this.endMatch(false); // Both players dead, defeat
        }
    }

    /**
     * Receives the Boss's state from the initiator (TEAM mode).
     */
    receiveBossState(state) {
        if (this.matchMode !== 'team_mp' || this.rtcManager.isInitiator) return;
        this.remoteEntity.hp = state.hp;
        this.remoteEntity.dead = state.dead;

        if (this.remoteEntity.dead) {
            this.endMatch(true); // Boss is dead, team victory
        }
    }

    /**
     * Receives a boss attack command from the initiator (TEAM mode).
     */
    receiveBossAttack(damage) {
        if (this.matchMode !== 'team_mp' || this.rtcManager.isInitiator) return;
        this.localPlayer.takeDamage(damage);
        this.showPopup(`TEAMMATE's BOSS ATTACK HIT YOU! -${damage} HP`, '#f00', 1500);
        this.sendLocalState(); // Send updated local HP back
        if (this.localPlayer.dead) {
            this.endMatch(false);
        }
    }

    /**
     * Sends a chat message over the data channel.
     */
    sendChatMessage() {
        const message = this.ui.chatInput.value.trim();
        if (message && this.isMultiplayer) {
            this.rtcManager.send({ type: 'chat', message });
            this.addChatMessage('You', message, '#0f0');
            this.ui.chatInput.value = '';
        } else if (message) {
            this.addChatMessage('SYSTEM', 'Cannot send chat in Solo Mode.', '#ff0');
            this.ui.chatInput.value = '';
        }
    }

    /**
     * Appends a chat message to the UI log.
     */
    addChatMessage(sender, message, color) {
        const msgEl = document.createElement('div');
        msgEl.innerHTML = `<span style="color:${color}; font-weight:bold;">[${sender}]:</span> ${message}`;
        this.ui.chatMessages.appendChild(msgEl);
        // Auto-scroll to bottom
        this.ui.chatMessages.scrollTop = this.ui.chatMessages.scrollHeight;
    }

    /**
     * Returns to the main menu/lobby after a match.
     */
    returnToLobby() {
        this.ui.hud.classList.add('hidden');
        document.getElementById('multiplayer-overlay').classList.add('hidden');
        if (this.matchMode.includes('_mp')) {
            // After an MP match, go back to the lobby selection state
            this.showMenu();
        } else {
            this.showMenu();
        }
    }
}

// =========================================================================
// MAIN EXECUTION AND ANIMATION LOOP
// =========================================================================

let gameInstance;

/**
 * The main game animation loop.
 */
function animate() {
    requestAnimationFrame(animate);
    if (gameInstance) {
        gameInstance.render();
    }
}

// Initialize the game instance when the window loads
window.onload = function () {
    gameInstance = new Game();
    animate(); // Start the animation loop
}

</script>
</body>
</html>

