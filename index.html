<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>KEYBOARD DOOM — V2.9 (Canvas Previews, Dragon Reflect, Unique Post-K Attacks, Troll Audio)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://www.youtube.com/iframe_api"></script>
<style>
/* Global Styles */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#000; overflow:hidden; touch-action:none; font-family: 'Inter', sans-serif; }
canvas { display:block; image-rendering:pixelated; cursor:none; }
#hud { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; color:#fff; }
.topleft { position:absolute; top:10px; left:10px; font-size:14px; text-shadow: 0 0 5px #0f0; }
.centertop { position:absolute; top:10px; left:50%; transform:translateX(-50%); font-size:18px; font-weight:bold; color: #ffeb3b; text-shadow: 0 0 8px #ffeb3b; }
.bottomcenter { position:absolute; bottom:10px; left:50%; transform:translateX(-50%); font-size:12px; opacity:.8; }
.status { position:absolute; top:60px; left:10px; font-size:12px; text-shadow: 0 0 3px #fff; }
.controls { position:absolute; bottom:40px; left:50%; transform:translateX(-50%); font-size:10px; color: #ff0000; text-shadow: 0 0 3px #ff0000; }

/* Menu & Game Over */
.menu, .gameover, .shop, .multiplayer-lobby {
    position:absolute; top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,.95); backdrop-filter: blur(5px);
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    color:#fff; transition: opacity 0.3s;
}
.hidden { opacity:0; pointer-events:none; position:absolute; }

.menu h1, .shop h1, .multiplayer-lobby h1 {
    font-size: 2.5rem; margin-bottom: 20px;
    color: #00ff44; text-shadow: 0 0 10px #00ff44;
    text-align: center;
}
.menu button, .shop button, .multiplayer-lobby button {
    background: #1e1e1e; border: 2px solid #00ff44; color: #00ff44;
    padding: 10px 20px; margin: 8px 0; border-radius: 8px;
    cursor: pointer; font-size: 16px; font-weight: bold;
    transition: all 0.2s ease-in-out;
    box-shadow: 0 0 5px #00ff44;
}
.menu button:hover, .shop button:hover, .multiplayer-lobby button:hover {
    background: #00ff44; color: #000; box-shadow: 0 0 15px #00ff44;
    transform: translateY(-2px);
}
.menu button:disabled {
    background: #333; border-color: #555; color: #888; cursor: not-allowed;
    box-shadow: none; transform: none;
}
.error-msg { color: #f55; margin-top: 10px; font-weight: bold; }

/* Cheat Code GUI */
#cheat-gui {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 10;
}
#cheat-input {
    background: #111;
    border: 1px solid #00ff44;
    color: #00ff44;
    padding: 5px 8px;
    font-size: 12px;
    border-radius: 4px;
    width: 80px;
}
#cheat-input:focus {
    outline: none;
    box-shadow: 0 0 5px #00ff44;
}

/* Keypad Grid (Your Choice Mode) */
#keypad {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    gap: 8px;
    width: 90vw;
    max-width: 800px;
    padding: 10px;
    background: rgba(30, 30, 30, 0.8);
    border: 1px solid #00ff44;
    border-radius: 10px;
    max-height: 40vh;
    overflow-y: auto;
    margin-top: 10px;
}
.key-btn {
    text-align: center;
    padding: 8px;
    font-size: 14px;
    background: #2a2a2a;
    border: 1px solid #00ff44;
    color: #00ff44;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.1s;
}
.key-btn:hover:not(.locked) {
    background: #00ff44;
    color: #000;
}
.key-btn.locked {
    background: #444;
    border-color: #555;
    color: #888;
    cursor: not-allowed;
    box-shadow: none;
    user-select: none;
}
.key-btn.current {
    background: #ff5500;
    border-color: #ff5500;
    color: #fff;
    box-shadow: 0 0 10px #ff5500;
    animation: pulse 1s infinite alternate;
}
@keyframes pulse {
    from { box-shadow: 0 0 10px #ff5500; }
    to { box-shadow: 0 0 15px #ff5500; }
}

/* Skins Shop Specifics */
.skin-card {
    background: #222;
    border: 1px solid #00ff44;
    border-radius: 8px;
    padding: 15px;
    margin: 10px;
    width: 250px;
    text-align: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 0 5px #00ff44;
    position: relative;
}
.skin-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 0 15px #00ff44;
}
.skin-card h3 {
    font-size: 1.2rem;
    color: #ffeb3b;
    margin-bottom: 5px;
}
.skin-card p {
    font-size: 0.85rem;
    color: #bbb;
    min-height: 40px;
    margin-bottom: 10px;
}
.skin-card .preview {
    font-size: 30px;
    line-height: 1;
    margin: 10px 0;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: skinPreviewPulse 2s infinite alternate; /* Add subtle animation to previews */
}
@keyframes skinPreviewPulse {
    from { opacity: 0.8; transform: scale(1); }
    to { opacity: 1; transform: scale(1.05); }
}
.skin-catalog {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-height: 70vh;
    overflow-y: auto;
}
.buff-tag {
    position: absolute;
    bottom: 5px;
    right: 5px;
    font-size: 0.75rem;
    font-weight: bold;
    background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}
#main-menu-buttons.hidden { display: none; }
#skinsShopBtn { display: block; }
</style>
</head>
<body>

<!-- Canvas for Game Rendering -->
<canvas id="gameCanvas"></canvas>

<!-- YouTube Player (Hidden) -->
<div id="ytplayer" style="position:absolute; top:-1000px; left:-1000px;"></div>

<!-- Heads Up Display (HUD) -->
<div id="hud">
    <div class="topleft">
        WAVE: <span id="waveInfo">1-1</span> | HP: <span id="hp"></span> | SHIELD: <span id="shield"></span><br>
        CREDITS: <span id="credits">0</span>
    </div>
    <div class="centertop">
        <span id="stageKey">A</span> | <span id="timer">20.0</span>s
    </div>
    <div class="bottomcenter">
        Press 'R' to return to menu (or 'R' at Game Over)
    </div>
    <div class="status" id="status"></div>
    <div class="controls" id="skinControls" style="display:none;"></div>
</div>

<!-- Main Menu -->
<div id="menu" class="menu">
    <h1>KEYBOARD DOOM</h1>
    <div id="main-menu-buttons">
        <button id="precodedBtn">World 1: Precoded (A-Z, 0-9)</button>
        <button id="precodedUniBtn">World 2: Precoded (Symbols & Unicode)</button>
        <button id="yourChoiceBtn">Your Choice Mode (Keypad)</button>
    </div>

    <!-- Shop is placed below modes -->
    <button id="skinsShopBtn">Skins Shop</button>
    <button id="audioToggle">Audio: OFF</button>

    <!-- Cheat Code GUI -->
    <div id="cheat-gui">
        <input type="text" id="cheat-input" placeholder="Code..." maxlength="10">
    </div>

    <div id="keypad" class="hidden"></div>
</div>

<!-- Skins Shop Modal -->
<div id="shop" class="shop hidden">
    <h1>Skins Shop</h1>
    <span class="text-xl mb-4 text-yellow-400">Your Credits: <span id="shopCredits">0</span></span>
    <div class="skin-catalog" id="skinCatalog">
        <!-- Skin cards rendered here -->
    </div>
    <button id="shopBackBtn" class="mt-4">Back to Menu</button>
</div>

<!-- Game Over Screen -->
<div id="gameover" class="gameover hidden">
    <h1>GAME OVER</h1>
    <p id="finalScore" class="text-xl mb-4 text-red-500"></p>
    <p class="text-lg text-gray-300">Press 'R' to restart</p>
</div>

<!-- Popup for transient messages (used instead of alert) -->
<div id="popup-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100;"></div>

<script type="module">
// --- FIREBASE IMPORTS AND SETUP (For future expansion/persistence) ---
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
const appId = typeof __app_id !== 'undefined' ? __app_id : 'keyboard-doom-v2';
let db, auth;
let userId = 'anon'; // Placeholder, will be updated by auth listener

if (firebaseConfig) {
    const app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    auth = getAuth(app);

    onAuthStateChanged(auth, async (user) => {
        if (user) {
            userId = user.uid;
            console.log("Firebase Authenticated. User ID:", userId);
            loadProgress();
        } else {
            console.log("Firebase Not Authenticated, signing in anonymously.");
            try {
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase Auth Error:", error);
                userId = crypto.randomUUID(); // Fallback to random ID
                loadProgress();
            }
        }
    });
} else {
    // If running outside the environment, use a fallback
    userId = 'local-user';
    console.warn("Firebase config not found. Running in local fallback mode.");
    loadProgress();
}


// --- YT PLAYER ---
let ytPlayer = null;
let speedInterval = null;
let ytReady = false;

function onYouTubeIframeAPIReady() {
    console.log('YouTube IFrame API Ready');
    ytReady = true;
    if (isAudioOn) {
        // If audio was toggled on before ready, start now
        setTimeout(() => {
            ytPlayer = new YT.Player('ytplayer', {
                height: '0',
                width: '0',
                videoId: 'OeemN2xFD6g',
                playerVars: {
                    'playsinline': 1,
                    'autoplay': 1,
                    'controls': 0,
                    'loop': 1,
                    'playlist': 'OeemN2xFD6g'
                },
                events: {
                    'onReady': function(event) {
                        event.target.playVideo();
                        changeSpeed();
                        speedInterval = setInterval(changeSpeed, 5000 + Math.random() * 5000);
                    },
                    'onStateChange': function(event) {
                        if (event.data === YT.PlayerState.ENDED) {
                            event.target.playVideo();
                        }
                    }
                }
            });
        }, 500);
    }
}

function changeSpeed() {
    if (ytPlayer && ytPlayer.getPlayerState() === 1) {
        const rate = 0.5 + Math.random() * 1.5; // Min 0.5, Max 2.0
        ytPlayer.setPlaybackRate(rate);
    }
}


// --- CORE GAME CONSTANTS & CONFIGURATIONS ---

// World Segregation - World 1: Alphanumeric (36 stages)
const WORLD1_KEYS = [
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
];

// World 2 - Symbols, Functional Keys, and Unicodes (79+ stages)
const WORLD2_SYMBOLS = [
    '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '-', '=',
    '[', ']', '{', '}', '|', '\\', ';', ':', "'", '"', ',', '.', '<', '>', '?', '/',
    'Space', 'Enter', 'Tab', 'Shift', 'Control', 'Alt', 'CapsLock', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
];
const WORLD2_UNICODE = [
    '→', '←', '▲', '▼', '☆', '★', '⚡', '∞', 'π', 'Ω', 'Σ', 'Φ',
    '§', 'µ', '©', '®', '™', '€', '£', '¥', '¢', '°', '±', '÷', '×',
    '≠', '≈', '≤', '≥', '∫', '∂', '∇', '√', '∛', '∜', '…', '‘', '’', '“', '”', '¶'
];
const WORLD2_FULL = [...WORLD2_SYMBOLS, ...WORLD2_UNICODE];

const MAX_HP = 100;
const MAX_SHIELD = 50;
const BASE_CREDITS = 50;
const BONUS_CREDITS = 150; // Max credits per win is BASE + BONUS = 200

// --- PERIODIC TABLE DATA FOR SKIN ---
const PERIODIC_ELEMENT_DATA = [
    { num: 1, symbol: 'H', weight: 1.008, color: '#add8e6', name: 'Hydrogen' }, // Non-metal
    { num: 2, symbol: 'He', weight: 4.002, color: '#fffacd', name: 'Helium' }, // Noble gas
    { num: 6, symbol: 'C', weight: 12.011, color: '#3cb371', name: 'Carbon' }, // Non-metal
    { num: 8, symbol: 'O', weight: 15.999, color: '#f08080', name: 'Oxygen' }, // Non-metal
    { num: 11, symbol: 'Na', weight: 22.990, color: '#8a2be2', name: 'Sodium' }, // Alkali metal
    { num: 17, symbol: 'Cl', weight: 35.453, color: '#90ee90', name: 'Chlorine' }, // Halogen
    { num: 19, symbol: 'K', weight: 39.098, color: '#9370db', name: 'Potassium' }, // Alkali metal
    { num: 26, symbol: 'Fe', weight: 55.845, color: '#bdb76b', name: 'Iron' }, // Transition metal
    { num: 29, symbol: 'Cu', weight: 63.546, color: '#b8860b', name: 'Copper' }, // Transition metal
    { num: 47, symbol: 'Ag', weight: 107.87, color: '#c0c0c0', name: 'Silver' }, // Transition metal
    { num: 79, symbol: 'Au', weight: 196.97, color: '#ffd700', name: 'Gold' }, // Transition metal
    { num: 80, symbol: 'Hg', weight: 200.59, color: '#cccccc', name: 'Mercury' }, // Transition metal
];

function getRandomPeriodicElement() {
    return PERIODIC_ELEMENT_DATA[Math.floor(Math.random() * PERIODIC_ELEMENT_DATA.length)];
}


// --- GAME STATE AND PROGRESS OBJECTS ---
const player = {
    x: 0, y: 0, radius: 10, speed: 4,
    hp: MAX_HP, maxHp: MAX_HP, shield: 0, maxShield: MAX_SHIELD,
    dead: false,
    credits: 0,
    equippedSkinId: 'default',
    skinState: { // For dynamic skins
        catBlinkTimer: 0,
        catBlinkDuration: 1200,
        catFace: 'owo',
        periodicElement: PERIODIC_ELEMENT_DATA[0], // Initialize with H
        arcadeFlicker: [], // For arcade skin flicker states
        grokAngle: 0, // For grok skin rotation
        dragonShieldAngle: 0, // For v2_dragon spinning shield
        retroBlinkTime: 0,
        whiteHoleActive: false, // White hole state
        whiteHoleTimer: 0
    }
};

const game = {
    mode: 'menu', // 'menu', 'precoded', 'precoded-uni', 'yourchoice'
    world: 'world1', // 'world1', 'world2', 'choice'
    keyset: null,
    stageIndex: 0,
    stageKey: 'A',
    timer: 0,
    score: 0,
    attacks: [],
    diggers: [],
    shake: 0,
    lastTime: 0,
    animationFrameId: null, // To store the ID of requestAnimationFrame
    lastDamageTime: 0,
    inChoiceMode: false,
    whiteHole: null, // White hole entity
    lastSpawnTime: 0, // For controlled spawning
    spawnInterval: 1000 // Default 1s
};

let progress = {
    world1: false, // World completion flag
    world2: false, // World completion flag
    // Fixed: Initial unlocked keys limited to a,b,c
    unlockedKeys: ['a', 'b', 'c'], 
    completedKeys: [],
    ownedSkins: ['default', 'retro_term', 'star_map', 'cat_txt', 'shards', 'periodic', 'dino_mode', 'hex_burst', 'neon_glow', 'glitch', 'matrix_code', 'plasma_orbs', 'cyber_grid', 'firefly_swarm', 'crystal_facet', 'void_portal', 'sunflare', 'ice_crystal', 'lava_flow', 'neural_net', 'quantum_flux', 'arcade_pixel', 'steampunk_gear', 'bioluminescent', 'holo_cube', 'shadow_puppeteer', 'electric_arc', 'flame_wisp', 'thorn_vine', 'echo_waveform', 'arcade', 'grok_xai'],
    equippedSkinId: 'default',
    credits: 0
};

// --- DOM ELEMENTS ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const hud = document.getElementById('hud');
const menu = document.getElementById('menu');
const gameover = document.getElementById('gameover');
const shop = document.getElementById('shop');
const keypad = document.getElementById('keypad');
const skinControls = document.getElementById('skinControls');

const precodedBtn = document.getElementById('precodedBtn');
const precodedUniBtn = document.getElementById('precodedUniBtn');
const yourChoiceBtn = document.getElementById('yourChoiceBtn');
const skinsShopBtn = document.getElementById('skinsShopBtn');
const shopBackBtn = document.getElementById('shopBackBtn');


// --- AUDIO TROLL ---
let isAudioOn = false;
let audioTimeouts = [];
function toggleAudio() {
    isAudioOn = !isAudioOn;
    document.getElementById('audioToggle').textContent = `Audio: ${isAudioOn ? 'ON' : 'OFF'}`;
    if (!isAudioOn) {
        audioTimeouts.forEach(clearTimeout);
        audioTimeouts = [];
        if (speedInterval) {
            clearInterval(speedInterval);
            speedInterval = null;
        }
        if (ytPlayer) {
            ytPlayer.pauseVideo();
        }
        return;
    }
    // YT Song
    if (ytReady) {
        if (!ytPlayer) {
            ytPlayer = new YT.Player('ytplayer', {
                height: '0',
                width: '0',
                videoId: 'OeemN2xFD6g',
                playerVars: {
                    'playsinline': 1,
                    'autoplay': 1,
                    'controls': 0,
                    'loop': 1,
                    'playlist': 'OeemN2xFD6g'
                },
                events: {
                    'onReady': function(event) {
                        event.target.playVideo();
                        changeSpeed();
                        speedInterval = setInterval(changeSpeed, 5000 + Math.random() * 5000);
                    },
                    'onStateChange': function(event) {
                        if (event.data === YT.PlayerState.ENDED) {
                            event.target.playVideo();
                        }
                    }
                }
            });
        } else {
            ytPlayer.playVideo();
            changeSpeed();
            speedInterval = setInterval(changeSpeed, 5000 + Math.random() * 5000);
        }
    } else {
        // Wait for ready
        const waitInterval = setInterval(() => {
            if (ytReady) {
                clearInterval(waitInterval);
                // Recurse to start
                toggleAudio();
            }
        }, 100);
    }
    // Legacy beep (disabled if YT)
    // const audioCtx = ... (commented out)
}


// --- CHEAT CODE GUI ---
document.addEventListener('DOMContentLoaded', () => {
    const cheatInput = document.getElementById('cheat-input');
    cheatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const code = cheatInput.value.toLowerCase().trim();
            if (code === 'nexus7') {
                // Unlock everything
                progress.ownedSkins = SKIN_CATALOG.map(s => s.id);
                player.credits = 1000000;
                progress.credits = 1000000;
                progress.unlockedKeys = [...WORLD1_KEYS, ...WORLD2_FULL];
                progress.completedKeys = [...WORLD1_KEYS, ...WORLD2_FULL];
                progress.world1 = true;
                progress.world2 = true;
                saveProgress();
                updateHUD();
                showPopup('NEXUS7 ACTIVATED! All Unlocked + 1M Credits!', canvas.width / 2, canvas.height / 2, 3000, '#00ff00');
                if (shop.classList.contains('hidden') === false) {
                    renderShopCatalog(); // Refresh if in shop
                }
                cheatInput.value = '';
            } else {
                showPopup('Invalid Code!', canvas.width / 2, canvas.height / 2 + 100, 1000, '#f55');
                cheatInput.value = '';
            }
        }
    });

    // Audio toggle
    document.getElementById('audioToggle').onclick = toggleAudio;
});


// --- FIREBASE PERSISTENCE FUNCTIONS ---
function getProgressRef() {
    return doc(db, "artifacts", appId, "users", userId, "progress", "state");
}

async function saveProgress() {
    if (db && userId) {
        progress.equippedSkinId = player.equippedSkinId; // Save equipped skin
        progress.unlockedKeys = Array.from(new Set(progress.unlockedKeys)); // Ensure unique keys
        progress.completedKeys = Array.from(new Set(progress.completedKeys));
        progress.credits = player.credits; // Ensure credits are saved
        try {
            await setDoc(getProgressRef(), progress);
        } catch(e) {
            console.error("Error saving progress:", e);
        }
    } else {
        localStorage.setItem(appId + '_progress', JSON.stringify(progress));
        localStorage.setItem(appId + '_credits', player.credits.toString());
        localStorage.setItem(appId + '_equippedSkin', player.equippedSkinId);
    }
}

async function loadProgress() {
    // Attempt to load from Firestore first
    if (db && userId) {
        try {
            const docSnap = await getDoc(getProgressRef());
            if (docSnap.exists()) {
                progress = docSnap.data();
                player.equippedSkinId = progress.equippedSkinId || 'default';
                player.credits = progress.credits || 0;
            } else {
                console.log("No progress found, initializing new state.");
                progress.credits = player.credits;
                await saveProgress();
            }
        } catch (e) {
            console.error("Error loading progress, falling back to local storage:", e);
            loadProgressLocal();
        }
    } else {
        loadProgressLocal();
    }
    applySkinBuffs();
    updateHUD();
}

function loadProgressLocal() {
    const localProgress = localStorage.getItem(appId + '_progress');
    const localCredits = localStorage.getItem(appId + '_credits');
    const localSkin = localStorage.getItem(appId + '_equippedSkin');

    if (localProgress) {
        progress = JSON.parse(localProgress);
    }
    if (localCredits) {
        player.credits = parseInt(localCredits);
    }
    if (localSkin) {
        player.equippedSkinId = localSkin;
    }
}

function applySkinBuffs() {
    const skin = SKIN_CATALOG.find(s => s.id === player.equippedSkinId);
    if (skin && skin.buffs) {
        player.maxHp = MAX_HP * (skin.buffs.hpMult || 1) + (skin.buffs.extraHp || 0);
        player.maxShield = MAX_SHIELD * (skin.buffs.shieldMult || 1) + (skin.buffs.extraShield || 0);
    } else {
        player.maxHp = MAX_HP;
        player.maxShield = MAX_SHIELD;
    }
    player.hp = Math.min(player.hp, player.maxHp);
    player.shield = Math.min(player.shield, player.maxShield);
}

// --- UTILITY AND DRAWING FUNCTIONS ---

function showPopup(text, x, y, duration, color = '#fff') {
    const container = document.getElementById('popup-container');
    const popup = document.createElement('div');
    popup.style.cssText = `
        position: absolute;
        left: ${x}px;
        top: ${y}px;
        transform: translate(-50%, -50%);
        padding: 5px 10px;
        background: ${color};
        color: #000;
        border-radius: 5px;
        font-size: 16px;
        font-weight: bold;
        opacity: 1;
        transition: all 0.5s ease-out;
        pointer-events: none;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
    `;
    popup.textContent = text;
    container.appendChild(popup);

    setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.top = (y - 50) + 'px';
        setTimeout(() => popup.remove(), 500);
    }, duration);
}

function updateHUD() {
    const keyset = game.mode === 'yourchoice' ? game.keyset : (game.world === 'world1' ? WORLD1_KEYS : WORLD2_FULL);
    const waveNumber = game.stageIndex + 1;
    const totalWaves = keyset ? keyset.length : 0;
    let worldDisplay = '';

    if (game.world === 'world1') worldDisplay = '1';
    else if (game.world === 'world2') worldDisplay = '2';
    else if (game.mode === 'yourchoice') worldDisplay = 'C'; // Choice Mode

    document.getElementById('waveInfo').textContent = `${worldDisplay}-${waveNumber} / ${totalWaves}`;
    document.getElementById('hp').textContent = Math.ceil(player.hp);
    document.getElementById('shield').textContent = Math.ceil(player.shield);
    document.getElementById('credits').textContent = player.credits;
    document.getElementById('stageKey').textContent = game.stageKey.toUpperCase(); // Show key in caps
    document.getElementById('timer').textContent = game.timer.toFixed(1);
    document.getElementById('shopCredits').textContent = player.credits; // Update shop display

    // Show controls for specific skins
    const skin = SKIN_CATALOG.find(s => s.id === player.equippedSkinId);
    if (skin && skin.controls) {
        skinControls.textContent = skin.controls;
        skinControls.style.display = 'block';
    } else {
        skinControls.style.display = 'none';
    }
}

function startShake(duration, intensity) {
    game.shake = intensity;
    setTimeout(() => game.shake = 0, duration);
}

// --- PLAYER AND SKIN LOGIC ---

// Skin Catalog (Debuffed regen rates halved, unique V2 buffs, modified dragon)
const SKIN_CATALOG = [
    { id: 'default', name: 'Base Dodecahedron', type: 'Static Glyph', price: 0, desc: 'The reliable geometry that protects you. Simple, robust, boring.', preview: '●', color: '#00ff44' },
    { id: 'retro_term', name: 'Vintage Terminal', type: 'Pixel/Trail Effect', price: 800, desc: 'Renders the player as a flashing green cursor block, leaving behind a brief ghost trail of \'console output\' text.', preview: '█', color: '#00ff00' },
    { id: 'star_map', name: 'Cosmic Starmap', type: 'Particle Cluster', price: 1800, desc: 'A swirling constellation of tiny stars that react to your movement.', preview: '✨', color: '#ffffff' }, 
    { id: 'cat_txt', name: 'cat.txt', type: 'Animated Text', price: 1500, desc: 'A glitching, animated text box that communicates its status via classic emoticon faces (owo, -w-, ;w;).', preview: 'owo', color: '#ffb300' },
    { id: 'shards', name: 'Flickering Shards', type: 'Dynamic Geometry', price: 2500, desc: 'The player breaks into small, flickering geometric shards when hit, unifying on recovery.', preview: '⬢', color: '#ff00ff' }, 
    { id: 'periodic', name: 'Periodic Table', type: 'Styled Box/Text', price: 2200, desc: 'Transforms into a color-coded element block, showing atomic data.', preview: 'Au', color: '#00ffff' },
    { id: 'dino_mode', name: 'Dinosaur Mode', type: 'Emoji', price: 500, desc: 'Transforms you into a majestic, low-cost dinosaur icon.', preview: '🦖', color: '#00cc00' }, 
    { id: 'hex_burst', name: 'Hex Code Burst', type: 'Dynamic Geometry', price: 3500, desc: 'The player is drawn as a cluster of constantly changing 6-digit hexadecimal color codes (based on player HP/shield status).', preview: '#A3FF4B', color: '#ff00ff' },
    { id: 'neon_glow', name: 'Neon Glow', type: 'Glowing Outline', price: 1200, desc: 'A pulsating neon outline that leaves a faint glow trail effect.', preview: '⟡', color: '#ff00ff' },
    { id: 'glitch', name: 'Glitch Effect', type: 'Distorted Render', price: 1600, desc: 'Player render with RGB split and scanline distortion.', preview: '█', color: '#ff0000' },
    { id: 'matrix_code', name: 'Matrix Code', type: 'Falling Code', price: 2000, desc: 'Surrounded by orbiting binary code digits.', preview: '01', color: '#00ff00' },
    { id: 'plasma_orbs', name: 'Plasma Orbs', type: 'Orbital Particles', price: 2800, desc: 'Multiple plasma orbs orbiting the core with electric arcs.', preview: '⚡', color: '#ff1493' },
    { id: 'cyber_grid', name: 'Cyber Grid', type: 'Wireframe', price: 900, desc: 'A holographic wireframe grid that rotates and pulses.', preview: '▱', color: '#00ffff' },
    { id: 'firefly_swarm', name: 'Firefly Swarm', type: 'Swarming Lights', price: 1900, desc: 'A swarm of tiny fireflies that flicker and follow movement patterns.', preview: '🪰', color: '#ffff00' },
    { id: 'crystal_facet', name: 'Crystal Facet', type: 'Prismatic', price: 2600, desc: 'Multi-faceted crystal that refracts light into rainbows.', preview: '💎', color: '#7fffd4' },
    { id: 'void_portal', name: 'Void Portal', type: 'Swirling Vortex', price: 3200, desc: 'A dark portal that sucks in light and emits shadowy tendrils.', preview: '🌀', color: '#4b0082' },
    { id: 'sunflare', name: 'Sunflare', type: 'Radiant Burst', price: 1400, desc: 'Solar flare effects with coronal mass ejections.', preview: '☀️', color: '#ffd700' },
    { id: 'ice_crystal', name: 'Ice Crystal', type: 'Fractal Snow', price: 1100, desc: 'Growing ice fractals that shimmer with frost.', preview: '❄️', color: '#add8e6' },
    { id: 'lava_flow', name: 'Lava Flow', type: 'Molten', price: 2300, desc: 'Slow-flowing lava with bubbling embers.', preview: '🌋', color: '#ff4500' },
    { id: 'neural_net', name: 'Neural Net', type: 'Synaptic', price: 3000, desc: 'Interconnected neural nodes firing signals.', preview: '🧠', color: '#9370db' },
    { id: 'quantum_flux', name: 'Quantum Flux', type: 'Waveform Interference', price: 3800, desc: 'Overlapping quantum waves that interfere and create probabilistic patterns.', preview: '⟐', color: '#8a2be2' },
    { id: 'arcade_pixel', name: 'Arcade Pixel', type: 'Retro Sprite', price: 600, desc: '8-bit pixel art sprite with dithering and scanlines.', preview: '⬜', color: '#ff69b4' },
    { id: 'steampunk_gear', name: 'Steampunk Gear', type: 'Mechanical', price: 1700, desc: 'Brass gears and pistons with steam exhaust effects.', preview: '⚙️', color: '#cd7f32' },
    { id: 'bioluminescent', name: 'Bioluminescent', type: 'Organic Glow', price: 2100, desc: 'Glowing jellyfish-like tendrils that pulse with bioluminescence.', preview: '🌊', color: '#00ced1' },
    { id: 'holo_cube', name: 'Holo Cube', type: '3D Projection', price: 2900, desc: 'Rotating holographic cube with wireframe edges.', preview: '⬞', color: '#87ceeb' },
    { id: 'shadow_puppeteer', name: 'Shadow Puppeteer', type: 'Silhouette', price: 1300, desc: 'Dynamic shadow puppet that morphs shapes.', preview: '🖤', color: '#000000' },
    { id: 'electric_arc', name: 'Electric Arc', type: 'Lightning', price: 2400, desc: 'Crackling electric arcs that chain between nodes.', preview: '⚡', color: '#ffff00' },
    { id: 'flame_wisp', name: 'Flame Wisp', type: 'Ethereal Fire', price: 1500, desc: 'Floating flame wisps that trail embers.', preview: '🔥', color: '#ff4500' },
    { id: 'thorn_vine', name: 'Thorn Vine', type: 'Organic Growth', price: 1800, desc: 'Twisting thorn vines that grow and retract.', preview: '🌿', color: '#228b22' },
    { id: 'echo_waveform', name: 'Echo Waveform', type: 'Audio Visualizer', price: 2700, desc: 'Oscillating waveforms that echo with sound-like pulses.', preview: '∿', color: '#ff1493' },
    { id: 'arcade', name: 'Arcade', type: 'Pixel Grid', price: 15000, desc: 'A 4x4 grid of fuzzy, semi-transparent squares alternating between orange and wine red, with random flickers and a bright bottom scanline.', preview: '⬜', color: '#ff69b4', buffs: {hpMult: 1.1, shieldMult: 1.05} },
    { id: 'grok_xai', name: 'Grok x.AI', type: 'Orbital Black Hole', price: 25000, desc: 'A central black hole with orbiting circles that shift from white to gray to black based on position around the event horizon, granting enhanced shields.', preview: '●', color: '#000000', buffs: {shieldMult: 1.5, regenRate: 0.005} }, // Halved
    // V2 Skins (Unique buffs, halved regen)
    { id: 'v2_nebula', name: 'V2 Nebula Vortex', type: 'Cosmic Swirl', price: 22000, desc: 'A breathtaking nebula vortex with swirling colors and particle bursts, visually stunning with +30% HP and slow shield regen.', preview: '🌌', color: '#8a2be2', buffs: {hpMult: 1.3, regenRate: 0.0075} }, // Halved
    { id: 'v2_photon', name: 'V2 Photon Storm', type: 'Energy Cascade', price: 18000, desc: 'Cascading photons in a radiant storm, impressive light refractions with extra shields.', preview: '☄️', color: '#ffd700', buffs: {extraShield: 50, shieldMult: 1.2} },
    { id: 'v2_chrono', name: 'V2 Chrono Rift', type: 'Temporal Distortion', price: 24000, desc: 'Rifting time waves with echoing distortions, elite visuals and HP boost.', preview: '⌛', color: '#4169e1', buffs: {hpMult: 1.4, extraHp: 30} },
    { id: 'v2_singularity', name: 'V2 Singularity Core', type: 'Gravitational Pull', price: 28000, desc: 'A pulling singularity with warped space effects, awe-inspiring with moderate regen.', preview: '🕳️', color: '#000', buffs: {regenRate: 0.01, shieldMult: 1.3} }, // Halved
    { id: 'v2_aurora', name: 'V2 Aurora Veil', type: 'Polar Lights', price: 20000, desc: 'Dancing aurora veils with spectral dances, beautiful buffs for endurance.', preview: '🌈', color: '#00ffff', buffs: {hpMult: 1.25, extraHp: 20, regenRate: 0.004} }, // Halved
    { id: 'v2_fusion', name: 'V2 Fusion Reactor', type: 'Plasma Containment', price: 26000, desc: 'Contained fusion with energy flares, reactor glows impressively with shield overcharge.', preview: '☢️', color: '#ff4500', buffs: {shieldMult: 1.6, extraShield: 30} },
    { id: 'v2_ethereal', name: 'V2 Ethereal Phantom', type: 'Ghostly Projections', price: 19000, desc: 'Phantom projections with spectral trails, hauntingly beautiful with HP regen.', preview: '👻', color: '#dda0dd', buffs: {hpMult: 1.2, regenRate: 0.006} }, // Halved
    { id: 'v2_dragon', name: 'V2 Dragonfire', type: 'Mythic Flames', price: 28000, desc: 'Code-drawn dragon with roaring flames and scales, epic visuals with dual buffs and spinnable red shield (Q/E) that reflects attacks.', preview: 'D', color: '#ff0000', buffs: {extraHp: 40, extraShield: 40}, controls: 'Q: Spin Shield Left | E: Spin Shield Right' },
    { id: 'v2_nexus', name: 'V2 Nexus Prism', type: 'Dimensional Refraction', price: 27000, desc: 'Prismatic nexus bending dimensions, refractive splendor with max endurance.', preview: '🔷', color: '#ff00ff', buffs: {hpMult: 1.5, shieldMult: 1.4} },
    { id: 'v2_apex', name: 'V2 Apex Predator', type: 'Bio-Luminescent Hunt', price: 30000, desc: 'Predatory form with hunting pulses, ferocious design with ultimate regen.', preview: '🦈', color: '#008000', buffs: {regenRate: 0.009, extraHp: 50} }, // Halved
    // Additional Skins
    { id: 'v2_cosmic', name: 'V2 Cosmic Entity', type: 'Galactic Form', price: 31000, desc: 'A cosmic being with embedded galaxies and stellar flares, ultimate visual complexity with balanced buffs.', preview: '🌟', color: '#ffffff', buffs: {hpMult: 1.6, shieldMult: 1.5} },
    { id: 'v2_chaos', name: 'V2 Chaos Engine', type: 'Fractal Chaos', price: 29000, desc: 'Ever-evolving fractal patterns of chaos, intricate and mesmerizing with regen focus.', preview: '🌀', color: '#ff1493', buffs: {regenRate: 0.0125, extraShield: 60} }, // Halved
    { id: 'v2_eternal', name: 'V2 Eternal Flame', type: 'Infinite Inferno', price: 32000, desc: 'An eternal flame core with layered fire rings and ember storms, supreme endurance design.', preview: '🔥', color: '#ff4500', buffs: {hpMult: 1.7, extraHp: 70} }
];

function renderPlayerSkin(ctx, x, y, radius, skinId, dt, skinState, hp, maxHp) {
    const skin = SKIN_CATALOG.find(s => s.id === skinId);
    if (!skin) return;

    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = skin.color;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;

    switch (skinId) {
        case 'default':
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            break;

        case 'cat_txt':
            // Fixed Blink/Idle Animation
            let catBlinkTimer = skinState.catBlinkTimer || 0;
            let catBlinkDuration = skinState.catBlinkDuration || 1200;
            catBlinkTimer += dt;
            let catFace = skinState.catFace || 'owo';
            if (catBlinkTimer > catBlinkDuration) {
                catFace = (catFace === 'owo') ? '-w-' : 'owo';
                skinState.catFace = catFace;
                catBlinkTimer = 0;
                catBlinkDuration = 1200 + Math.random() * 300;
            }
            skinState.catBlinkTimer = catBlinkTimer;
            skinState.catBlinkDuration = catBlinkDuration;

            // Damage/Low HP State (Override)
            if (hp < maxHp * 0.3) {
                catFace = ';w;';
            }

            ctx.font = 'bold 24px Inter';
            ctx.textAlign = 'center';
            ctx.fillText(catFace, 0, 8);
            ctx.strokeText(catFace, 0, 8);
            break;

        case 'periodic':
            const element = skinState.periodicElement || PERIODIC_ELEMENT_DATA[0];
            const elementSize = 30;
            const elementBorderColor = '#333';
            
            ctx.save();
            ctx.translate(-elementSize / 2, -elementSize / 2); // Center the box
            
            // 1. Draw Element Background and Border
            ctx.fillStyle = element.color || '#cccccc';
            ctx.fillRect(0, 0, elementSize, elementSize);
            
            ctx.strokeStyle = elementBorderColor;
            ctx.lineWidth = 1.5;
            ctx.strokeRect(0, 0, elementSize, elementSize);
            
            // 2. Draw Atomic Number (Top Left)
            ctx.font = '7px Inter';
            ctx.fillStyle = elementBorderColor;
            ctx.textAlign = 'left';
            ctx.fillText(element.num.toString(), 2, 8);
            
            // 3. Draw Symbol (Center)
            ctx.font = 'bold 15px Inter';
            ctx.fillStyle = elementBorderColor;
            ctx.textAlign = 'center';
            ctx.fillText(element.symbol, elementSize / 2, elementSize / 2 + 5);
            
            // 4. Draw Atomic Weight (Bottom Center)
            ctx.font = '6px Inter';
            ctx.fillStyle = elementBorderColor;
            ctx.textAlign = 'center';
            ctx.fillText(element.weight.toFixed(3), elementSize / 2, elementSize - 3);

            ctx.restore();
            break;
            
        case 'dino_mode': 
            ctx.font = 'bold 24px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('🦖', 0, 8);
            break;

        case 'retro_term':
            // Fixed animated cursor: blinking bars
            const retroBlinkTime = (skinState.retroBlinkTime || 0) + dt;
            skinState.retroBlinkTime = retroBlinkTime % 1000;
            const blinkOn = Math.floor(retroBlinkTime / 500) % 2 === 0;

            ctx.fillStyle = '#000';
            ctx.fillRect(-radius, -radius, radius * 2, radius * 2);
            ctx.fillStyle = '#00ff00';
            // Left bar (static)
            ctx.fillRect(-radius, -radius, 2, radius * 2);
            // Right bar (blinking)
            if (blinkOn) {
                ctx.fillRect(radius - 2, -radius, 2, radius * 2);
            }
            // Top and bottom lines for block feel
            ctx.fillRect(-radius, -radius, radius * 2, 2);
            ctx.fillRect(-radius, radius - 2, radius * 2, 2);
            break;
            
        case 'shards': 
            const isDamaged = hp < maxHp * 0.5;
            if (isDamaged) {
                // Flicker and draw as small scattered triangles
                if (Math.floor(Date.now() / 50) % 2 === 0) {
                    ctx.globalAlpha = 0.6;
                }
                for(let i=0; i<5; i++) {
                    const angle = i * Math.PI / 2.5;
                    ctx.save();
                    ctx.rotate(angle);
                    ctx.translate(Math.random()*4 - 2, Math.random()*4 - 2);
                    ctx.beginPath();
                    ctx.moveTo(radius, 0);
                    ctx.lineTo(radius * -0.5, radius * 0.866);
                    ctx.lineTo(radius * -0.5, radius * -0.866);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }
                ctx.globalAlpha = 1;
            } else {
                // Draw as a solid hexagon when healthy
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    const rx = radius * Math.cos(angle);
                    const ry = radius * Math.sin(angle);
                    if (i === 0) ctx.moveTo(rx, ry);
                    else ctx.lineTo(rx, ry);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            break;
            
        case 'star_map': 
            const starCount = 20;
            ctx.globalAlpha = 0.8;
            for (let i = 0; i < starCount; i++) {
                // Simple sine-wave movement for twinkling/swirling
                const angle = (i * 0.3) + (Date.now() * 0.001);
                const r = radius * 0.8 + Math.sin(Date.now() * 0.005 + i) * 2;
                const starSize = 1 + Math.random() * 1.5;
                ctx.fillRect(Math.cos(angle) * r, Math.sin(angle) * r, starSize, starSize);
            }
            ctx.globalAlpha = 1;
            break;


        case 'hex_burst':
            const baseColor = (hp > 50) ? '#00FF00' : (hp > 20 ? '#FFFF00' : '#FF0000');
            const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
            ctx.fillStyle = baseColor;
            ctx.globalAlpha = pulse;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.7 * pulse, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Draw small hex codes around the player
            for(let i=0; i<6; i++) {
                const angle = i * Math.PI / 3 + Date.now() * 0.001;
                const offset = radius * 1.5;
                const hexCode = Math.floor(Math.random()*16777215).toString(16).padStart(6, '0').toUpperCase();
                ctx.font = '8px Inter';
                ctx.fillText('#' + hexCode, Math.cos(angle) * offset, Math.sin(angle) * offset);
            }
            break;

        case 'neon_glow':
            ctx.shadowColor = skin.color;
            ctx.shadowBlur = 10 + Math.sin(Date.now() / 200) * 3;
            ctx.strokeStyle = skin.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
            break;

        case 'glitch':
            // RGB split effect
            ctx.save();
            ctx.translate(1, 0);
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.save();
            ctx.translate(-1, 0);
            ctx.fillStyle = '#00f';
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            break;

        case 'matrix_code':
            // Orbiting binary digits
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = skin.color;
            ctx.font = '6px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI / 3) + (Date.now() * 0.002);
                const r = radius + 6 + i * 2;
                const char = Math.random() > 0.5 ? '0' : '1';
                ctx.fillText(char, Math.cos(angle) * r, Math.sin(angle) * r);
            }
            break;

        case 'plasma_orbs':
            // Orbiting orbs with arcs
            for (let i = 0; i < 3; i++) {
                const angle = (i * Math.PI * 2 / 3) + (Date.now() * 0.003);
                const r = radius + 10;
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * r, Math.sin(angle) * r, 2, 0, Math.PI * 2);
                ctx.fill();
                // Arc to center
                ctx.strokeStyle = skin.color;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                ctx.stroke();
            }
            break;

        case 'cyber_grid':
            // Rotating wireframe
            ctx.save();
            ctx.rotate(Date.now() * 0.001);
            ctx.strokeStyle = skin.color;
            ctx.lineWidth = 0.5;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    ctx.beginPath();
                    ctx.moveTo(i * radius, j * radius);
                    ctx.lineTo(0, 0);
                    ctx.stroke();
                }
            }
            ctx.restore();
            break;

        case 'firefly_swarm':
            // Flickering dots
            ctx.globalAlpha = 0.7;
            for (let i = 0; i < 10; i++) {
                const angle = i * 0.4 + Date.now() * 0.004;
                const r = radius * 0.5 + Math.sin(Date.now() * 0.01 + i) * 3;
                const alpha = 0.5 + Math.sin(Date.now() * 0.02 + i) * 0.5;
                ctx.globalAlpha = alpha;
                ctx.fillRect(Math.cos(angle) * r, Math.sin(angle) * r, 1, 1);
            }
            ctx.globalAlpha = 1;
            break;

        case 'crystal_facet':
            // Multi-faceted draw
            ctx.save();
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3;
                ctx.save();
                ctx.rotate(angle);
                ctx.fillStyle = `hsl(${i * 60}, 100%, 70%)`;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(radius, 0);
                ctx.lineTo(radius * 0.5, radius * 0.866);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
            ctx.restore();
            break;

        case 'void_portal':
            // Swirling darkness
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 2);
            gradient.addColorStop(0, '#000');
            gradient.addColorStop(1, skin.color);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 2, 0, Math.PI * 2);
            ctx.fill();
            break;

        case 'sunflare':
            // Radiant rays
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.5, 0, Math.PI * 2);
            ctx.fill();
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3 + Date.now() * 0.005;
                ctx.strokeStyle = skin.color;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * radius * 1.5, Math.sin(angle) * radius * 1.5);
                ctx.stroke();
            }
            break;

        case 'ice_crystal':
            // Fractal lines
            ctx.strokeStyle = skin.color;
            ctx.lineWidth = 1;
            function drawBranch(len, angle) {
                if (len < 1) return;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
                ctx.stroke();
                drawBranch(len * 0.7, angle + 0.3);
                drawBranch(len * 0.7, angle - 0.3);
            }
            drawBranch(radius, 0);
            break;

        case 'lava_flow':
            // Bubbling blobs
            ctx.fillStyle = skin.color;
            for (let i = 0; i < 3; i++) {
                const rx = Math.sin(Date.now() * 0.003 + i) * 2;
                const ry = Math.cos(Date.now() * 0.002 + i) * 2;
                ctx.beginPath();
                ctx.arc(rx, ry, radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
            // Embers
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 3; i++) {
                ctx.fillRect(Math.random() * radius * 2 - radius, Math.random() * radius * 2 - radius, 0.5, 0.5);
            }
            break;

        case 'neural_net':
            // Connected nodes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = skin.color;
            for (let i = 0; i < 4; i++) {
                const angle = i * Math.PI / 2;
                const r = radius * 0.5;
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * r, Math.sin(angle) * r, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = skin.color;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                ctx.stroke();
            }
            break;

        case 'quantum_flux':
            // Wave interference
            ctx.strokeStyle = skin.color;
            ctx.lineWidth = 0.5;
            for (let i = 0; i < 2; i++) {
                const offset = i * 5 + Date.now() * 0.01;
                ctx.beginPath();
                for (let j = 0; j < 360; j += 30) {
                    const rad = j * Math.PI / 180;
                    const wave = Math.sin(rad + offset) * 3;
                    const rx = Math.cos(rad) * (radius + wave);
                    const ry = Math.sin(rad) * (radius + wave);
                    if (j === 0) ctx.moveTo(rx, ry);
                    else ctx.lineTo(rx, ry);
                }
                ctx.closePath();
                ctx.stroke();
            }
            break;

        case 'arcade_pixel':
            // Pixelated sprite
            ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = skin.color;
            for (let px = -radius; px < radius; px += 2) {
                for (let py = -radius; py < radius; py += 2) {
                    if (Math.random() > 0.5) ctx.fillRect(px, py, 2, 2);
                }
            }
            // Scanlines
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < radius * 2; i += 1) {
                ctx.beginPath();
                ctx.moveTo(-radius, i - radius);
                ctx.lineTo(radius, i - radius);
                ctx.stroke();
            }
            break;

        case 'steampunk_gear':
            // Gears
            ctx.fillStyle = '#cd7f32';
            ctx.beginPath();
            ctx.moveTo(radius, 0);
            for (let i = 1; i < 8; i++) {
                const angle = i * Math.PI / 4;
                ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
            ctx.closePath();
            ctx.fill();
            // Rotate
            ctx.save();
            ctx.rotate(Date.now() * 0.005);
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
            break;

        case 'bioluminescent':
            // Pulsing tendrils
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3 + Math.sin(Date.now() * 0.005) * 0.1;
                const len = radius + Math.sin(Date.now() * 0.01 + i) * 6;
                ctx.strokeStyle = skin.color;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.8 + Math.sin(Date.now() * 0.02 + i) * 0.2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            break;

        case 'holo_cube':
            // 3D cube projection
            ctx.strokeStyle = skin.color;
            ctx.lineWidth = 1;
            const rotX = Date.now() * 0.001;
            const rotY = Date.now() * 0.002;
            const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
            const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
            const verts = [
                [-5, -5, -5], [5, -5, -5], [5, 5, -5], [-5, 5, -5],
                [-5, -5, 5], [5, -5, 5], [5, 5, 5], [-5, 5, 5]
            ].map(v => ({
                x: v[0] * cosY - v[2] * sinY,
                y: (v[1] * cosX - v[2] * sinX) * 10,
                z: v[0] * sinY + v[2] * cosY
            }));
            // Draw edges (simplified)
            const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
            edges.forEach(e => {
                ctx.beginPath();
                ctx.moveTo(verts[e[0]].x + radius / 2, verts[e[0]].y + radius / 2);
                ctx.lineTo(verts[e[1]].x + radius / 2, verts[e[1]].y + radius / 2);
                ctx.stroke();
            });
            break;

        case 'shadow_puppeteer':
            // Morphing shadow
            const morph = Math.sin(Date.now() / 1000);
            ctx.fillStyle = '#000';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.ellipse(0, 0, radius * (1 + morph * 0.5), radius * (1 - morph * 0.3), 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            break;

        case 'electric_arc':
            // Arcing lightning
            ctx.strokeStyle = skin.color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.7;
            for (let i = 0; i < 3; i++) {
                const startAngle = i * Math.PI * 2 / 3;
                const endAngle = startAngle + Math.PI;
                const midX = Math.cos(startAngle + Math.PI / 2) * radius * 0.5;
                const midY = Math.sin(startAngle + Math.PI / 2) * radius * 0.5;
                ctx.beginPath();
                ctx.moveTo(Math.cos(startAngle) * radius, Math.sin(startAngle) * radius);
                ctx.quadraticCurveTo(midX + (Math.random()-0.5)*5, midY + (Math.random()-0.5)*5, Math.cos(endAngle) * radius, Math.sin(endAngle) * radius);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            break;

        case 'flame_wisp':
            // Floating flames
            for (let i = 0; i < 4; i++) {
                const angle = i * Math.PI * 2 / 4 + Date.now() * 0.004;
                const r = radius * 0.3 + Math.sin(Date.now() * 0.01 + i) * 3;
                ctx.fillStyle = `rgba(255, 69, 0, ${0.6 + Math.sin(Date.now() * 0.03 + i) * 0.4})`;
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * r, Math.sin(angle) * r, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
            break;

        case 'thorn_vine':
            // Twisting vines (Updated to 4 arms)
            ctx.strokeStyle = skin.color;
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) { // Changed from 3 to 4
                const baseAngle = i * Math.PI / 2; // 90 degrees for 4 arms
                ctx.save();
                ctx.rotate(baseAngle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                for (let j = 0; j < 15; j++) {
                    const t = j / 15;
                    const rx = t * radius * 1.2;
                    const ry = Math.sin(t * Math.PI * 3 + Date.now() * 0.005) * 3;
                    if (j === 0) ctx.moveTo(rx, ry);
                    else ctx.lineTo(rx, ry);
                }
                ctx.stroke();
                ctx.restore();
            }
            break;

        case 'echo_waveform':
            // Waveforms
            ctx.strokeStyle = skin.color;
            ctx.lineWidth = 0.5;
            const time = Date.now() * 0.001;
            for (let i = 0; i < 2; i++) {
                const offset = i * Math.PI / 2 + time;
                ctx.beginPath();
                for (let j = 0; j < 360; j += 30) {
                    const rad = j * Math.PI / 180;
                    const r = radius + Math.sin(rad * 2 + offset) * 6;
                    const rx = Math.cos(rad) * r;
                    const ry = Math.sin(rad) * r;
                    if (j === 0) ctx.moveTo(rx, ry);
                    else ctx.lineTo(rx, ry);
                }
                ctx.closePath();
                ctx.stroke();
            }
            break;

        case 'arcade':
            // 4x4 grid of squares, alternating orange/wine red, dark semi-transparent fuzzy, random flicker, bright bottom line
            const gridSize = radius * 1.5 / 4; // Size per square
            const orange = '#8b4513'; // Darker orange
            const wineRed = '#4a1f23'; // Darker wine red
            const brightLine = '#ff4500'; // Brighter for bottom line
            let arcadeFlicker = skinState.arcadeFlicker || Array(16).fill(false);

            // Update flickers (random per square)
            for (let i = 0; i < 16; i++) {
                if (Math.random() < 0.02) { // ~2% chance per frame to flicker
                    arcadeFlicker[i] = !arcadeFlicker[i];
                }
            }
            skinState.arcadeFlicker = arcadeFlicker;

            // Smooth alternate: global hue shift over time for the grid
            const globalShift = Math.sin(Date.now() / 1000) * 0.1; // Subtle shift

            ctx.globalAlpha = 0.4; // Semi-transparent base
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const idx = row * 4 + col;
                    const rx = (col - 1.5) * gridSize;
                    const ry = (row - 1.5) * gridSize;
                    const isOrange = ((row + col) % 2 === 0);
                    let color = isOrange ? orange : wineRed;
                    // Fuzzy: draw as small blurred rects or multiple dots (simple: alpha vary)
                    const flickerAlpha = arcadeFlicker[idx] ? 0.8 : 0.2;
                    ctx.globalAlpha = 0.4 * flickerAlpha;
                    ctx.fillStyle = color;
                    ctx.fillRect(rx, ry, gridSize, gridSize);
                }
            }
            ctx.globalAlpha = 1;

            // Bottom scanline (brighter)
            ctx.fillStyle = brightLine;
            ctx.fillRect(-radius * 0.75, radius * 0.4, radius * 1.5, 2);
            break;

        case 'grok_xai':
            // Black hole center with outline, 8 spinning circles changing from white-gray-black based on position
            // Center black hole
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = '#000';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Update rotation
            let grokAngle = (skinState.grokAngle || 0) + dt * 0.001;
            skinState.grokAngle = grokAngle;

            // 8 orbiting circles
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI / 4) + grokAngle;
                const r = radius * 1.2;
                const ox = Math.cos(angle) * r;
                const oy = Math.sin(angle) * r;
                ctx.beginPath();
                ctx.arc(ox, oy, 2, 0, Math.PI * 2);
                // Color: white-gray-black based on position (cosine for smooth gradient)
                const lightness = 50 + 50 * Math.cos(angle);
                ctx.fillStyle = `hsl(0, 0%, ${lightness}%)`;
                ctx.fill();
            }
            break;

        // V2 Skins Renders (Enhanced for complexity: more particles, layers, effects)
        case 'v2_nebula':
            // Multi-layer swirling nebula with 20+ particles and gradient bursts
            const nebulaGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 2.5);
            nebulaGradient.addColorStop(0, '#8a2be2');
            nebulaGradient.addColorStop(0.3, '#4b0082');
            nebulaGradient.addColorStop(0.7, '#000080');
            nebulaGradient.addColorStop(1, '#000');
            ctx.fillStyle = nebulaGradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 2.5, 0, Math.PI * 2);
            ctx.fill();
            // Enhanced particles: 20 swirling with trails
            for (let i = 0; i < 20; i++) {
                const pAngle = i * Math.PI / 10 + Date.now() * 0.003;
                const pr = radius * (1.2 + Math.sin(pAngle * 2) * 0.5);
                const trailLen = Math.sin(Date.now() * 0.01 + i) * 5;
                ctx.strokeStyle = `hsl(${pAngle * 180 / Math.PI + Date.now() * 0.1}, 100%, 70%)`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(Math.cos(pAngle) * (pr - trailLen), Math.sin(pAngle) * (pr - trailLen));
                ctx.lineTo(Math.cos(pAngle) * pr, Math.sin(pAngle) * pr);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(Math.cos(pAngle) * pr, Math.sin(pAngle) * pr, 2, 0, Math.PI * 2);
                ctx.fillStyle = ctx.strokeStyle;
                ctx.fill();
            }
            break;

        case 'v2_photon':
            // Cascading photons with refractions and 16+ beams
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.8, 0, Math.PI * 2);
            ctx.fill();
            for (let i = 0; i < 16; i++) {
                const angle = i * Math.PI / 8 + Date.now() * 0.005;
                const dist = radius + Math.sin(angle * 3) * 8;
                const refraction = Math.sin(Date.now() * 0.01 + i) * 2;
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 1 + Math.sin(Date.now() * 0.02 + i) * 0.5;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(Math.cos(angle) * (dist / 2) + refraction, Math.sin(angle) * (dist / 2) + refraction, Math.cos(angle) * dist, Math.sin(angle) * dist);
                ctx.stroke();
            }
            // Core pulse
            const corePulse = Math.sin(Date.now() / 150) * 0.3 + 0.7;
            ctx.globalAlpha = corePulse;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            break;

        case 'v2_chrono':
            // Temporal waves with echoing distortions and 5+ layered waves
            ctx.strokeStyle = '#4169e1';
            ctx.lineWidth = 1.5;
            const chronoTime = Date.now() * 0.002;
            for (let i = 0; i < 5; i++) {
                const waveOffset = i * 2;
                ctx.globalAlpha = 0.6 / i || 0.6;
                ctx.beginPath();
                for (let j = 0; j <= 360; j += 10) {
                    const rad = j * Math.PI / 180;
                    const wave = Math.sin(rad * (2 + i * 0.5) + chronoTime + waveOffset) * (radius + i * 3);
                    const echoDistort = Math.cos(chronoTime * 2 + j) * 2;
                    const rx = Math.cos(rad) * wave + echoDistort;
                    const ry = Math.sin(rad) * wave;
                    if (j === 0) ctx.moveTo(rx, ry);
                    else ctx.lineTo(rx, ry);
                }
                ctx.closePath();
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            break;

        case 'v2_singularity':
            // Pulling gravity with warped space and 8+ tendrils with distortion
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.2, 0, Math.PI * 2);
            ctx.fill();
            // Event horizon ring
            ctx.strokeStyle = '#4b0082';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.2, 0, Math.PI * 2);
            ctx.stroke();
            for (let i = 0; i < 8; i++) {
                const angle = i * Math.PI / 4;
                const warp = Math.sin(Date.now() * 0.005 + i) * 0.5;
                ctx.strokeStyle = `rgba(75, 0, 130, ${0.7 + Math.sin(Date.now() * 0.01 + i) * 0.3})`;
                ctx.lineWidth = 2 + warp * 2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle + warp) * radius * 1.1, Math.sin(angle + warp) * radius * 1.1);
                ctx.quadraticCurveTo(Math.cos(angle) * radius * 1.5, Math.sin(angle) * radius * 1.5, Math.cos(angle - warp) * (radius * 2.5), Math.sin(angle - warp) * (radius * 2.5));
                ctx.stroke();
            }
            break;

        case 'v2_aurora':
            // Dancing lights with 10+ spectral layers and curvature
            const auroraTime = Date.now() * 0.004;
            for (let i = 0; i < 10; i++) {
                const angle = auroraTime + i * Math.PI * 0.8;
                const len = radius * (1.5 + Math.sin(auroraTime * 2 + i) * 0.8);
                const hue = (auroraTime * 50 + i * 30) % 360;
                ctx.strokeStyle = `hsla(${hue}, 100%, 60%, 0.8)`;
                ctx.lineWidth = 4 - i * 0.3;
                ctx.globalAlpha = 0.6 + Math.sin(auroraTime * 3 + i) * 0.4;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                for (let j = 0; j < 20; j++) {
                    const t = j / 20;
                    const curveX = Math.cos(angle) * t * len + Math.sin(auroraTime * 5 + j) * 2;
                    const curveY = Math.sin(angle) * t * len + Math.cos(auroraTime * 4 + j) * 1.5;
                    if (j === 0) ctx.moveTo(curveX, curveY);
                    else ctx.lineTo(curveX, curveY);
                }
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            break;

        case 'v2_fusion':
            // Reactor flares with 12+ energy bursts and plasma containment field
            ctx.fillStyle = '#ff4500';
            ctx.beginPath();
            const fusionPulse = Math.sin(Date.now() / 100) * 0.4 + 0.6;
            ctx.arc(0, 0, radius * fusionPulse, 0, Math.PI * 2);
            ctx.fill();
            // Containment field
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.3, 0, Math.PI * 2);
            ctx.stroke();
            // Enhanced flares: 12 with random bursts
            for (let i = 0; i < 12; i++) {
                const flareAngle = i * Math.PI / 6 + Math.sin(Date.now() * 0.007 + i) * 0.3;
                const flareLen = radius * 2 + Math.random() * 5;
                const burstAlpha = 0.4 + Math.random() * 0.5;
                ctx.fillStyle = `rgba(255, 165, 0, ${burstAlpha})`;
                ctx.globalAlpha = burstAlpha;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(flareAngle) * flareLen, Math.sin(flareAngle) * flareLen);
                ctx.lineTo(Math.cos(flareAngle + 0.2) * flareLen * 0.8, Math.sin(flareAngle + 0.2) * flareLen * 0.8);
                ctx.closePath();
                ctx.fill();
                // Inner ember particles
                for (let p = 0; p < 3; p++) {
                    const px = Math.cos(flareAngle) * (flareLen * 0.3 + p * 2), py = Math.sin(flareAngle) * (flareLen * 0.3 + p * 2);
                    ctx.fillRect(px - 0.5, py - 0.5, 1, 1);
                }
            }
            ctx.globalAlpha = 1;
            break;

        case 'v2_ethereal':
            // Spectral trails with 8+ ghostly layers and fade effects
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = '#dda0dd';
            for (let i = 0; i < 8; i++) {
                const trailAngle = i * Math.PI * 2 / 8 + Date.now() * 0.003;
                const trailR = radius + i * 4;
                const fade = 0.8 - i * 0.08;
                ctx.globalAlpha = fade;
                ctx.beginPath();
                ctx.arc(Math.cos(trailAngle) * trailR, Math.sin(trailAngle) * trailR, 4 - i * 0.3, 0, Math.PI * 2);
                ctx.fill();
                // Trail lines
                ctx.strokeStyle = '#dda0dd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(trailAngle) * trailR, Math.sin(trailAngle) * trailR);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.strokeStyle = '#dda0dd';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            break;

        case 'v2_dragon':
            // Code-drawn dragon body (simple polygonal shape for head, body, wings)
            ctx.fillStyle = '#8B4513'; // Brown scales
            ctx.beginPath();
            // Body
            ctx.ellipse(0, 0, radius * 1.2, radius * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            // Head
            ctx.beginPath();
            ctx.ellipse(radius * 0.8, 0, radius * 0.4, radius * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            // Wings (two simple triangles)
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-radius * 0.8, -radius * 0.5);
            ctx.lineTo(-radius * 0.8, radius * 0.5);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(radius * 0.8, -radius * 0.5);
            ctx.lineTo(radius * 0.8, radius * 0.5);
            ctx.closePath();
            ctx.fill();
            // Flame breath (orange triangle forward)
            ctx.fillStyle = '#FF4500';
            ctx.beginPath();
            ctx.moveTo(radius * 1.2, 0);
            ctx.lineTo(radius * 1.8, -radius * 0.2);
            ctx.lineTo(radius * 1.8, radius * 0.2);
            ctx.closePath();
            ctx.fill();
            // Spikes (from diep.io style: triangular spikes around body)
            ctx.fillStyle = '#654321';
            for (let i = 0; i < 6; i++) {
                const spikeAngle = i * Math.PI / 3;
                ctx.save();
                ctx.translate(0, 0);
                ctx.rotate(spikeAngle);
                ctx.beginPath();
                ctx.moveTo(radius * 0.5, 0);
                ctx.lineTo(radius * 0.8, -radius * 0.3);
                ctx.lineTo(radius * 0.8, radius * 0.3);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
            // Red spinning shield
            const dragonShieldAngle = skinState.dragonShieldAngle || 0;
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, radius + 8, dragonShieldAngle, dragonShieldAngle + Math.PI * 1.5);
            ctx.stroke();
            break;

        case 'v2_nexus':
            // Bending prisms with 8+ refractive layers and shadow glow
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff00ff';
            for (let i = 0; i < 8; i++) {
                ctx.save();
                const prismRot = i * Math.PI / 4 + Date.now() * 0.002;
                ctx.rotate(prismRot);
                ctx.fillStyle = `hsl(${i * 45}, 100%, ${70 + Math.sin(Date.now() * 0.01 + i) * 20}%)`;
                for (let j = 0; j < 3; j++) { // Multi-facet per prism
                    ctx.beginPath();
                    ctx.rect(-radius * 0.4 + j * 0.2, -radius * 0.4, radius * 0.8, radius * 0.8);
                    ctx.fill();
                }
                ctx.restore();
            }
            ctx.restore();
            ctx.shadowBlur = 0;
            break;

        case 'v2_apex':
            // Hunting pulses with 6+ bio-lum rings and predatory spikes
            const pulseRadius = radius + Math.sin(Date.now() / 200) * 8;
            ctx.fillStyle = '#008000';
            ctx.beginPath();
            ctx.arc(0, 0, pulseRadius, 0, Math.PI * 2);
            ctx.fill();
            // Enhanced pulse rings: 6 with varying speeds
            for (let i = 1; i < 6; i++) {
                const ringR = pulseRadius + i * 10 + Math.sin(Date.now() / (150 / i)) * 3;
                const ringAlpha = 0.6 / i;
                ctx.globalAlpha = ringAlpha;
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3 - i * 0.4;
                ctx.beginPath();
                ctx.arc(0, 0, ringR, 0, Math.PI * 2);
                ctx.stroke();
                // Spikes
                for (let s = 0; s < 3; s++) {
                    const spikeAngle = s * Math.PI * 2 / 3 + Date.now() * 0.01;
                    ctx.lineTo(Math.cos(spikeAngle) * (ringR + 5), Math.sin(spikeAngle) * (ringR + 5));
                }
            }
            ctx.globalAlpha = 1;
            break;

        // Additional Skins Renders
        case 'v2_cosmic':
            // Galactic form with embedded stars, nebulae swirls, and flare bursts
            const cosmicGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 3);
            cosmicGrad.addColorStop(0, '#ffffff');
            cosmicGrad.addColorStop(0.4, '#8a2be2');
            cosmicGrad.addColorStop(0.8, '#000080');
            cosmicGrad.addColorStop(1, '#000');
            ctx.fillStyle = cosmicGrad;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 3, 0, Math.PI * 2);
            ctx.fill();
            // Embedded galaxies: 15 swirling stars
            for (let i = 0; i < 15; i++) {
                const gAngle = i * Math.PI / 7.5 + Date.now() * 0.0025;
                const gr = radius * 0.7 + Math.sin(gAngle * 1.5) * 4;
                ctx.fillStyle = `hsl(${gAngle * 180 / Math.PI}, 100%, ${80 + Math.random() * 20}%)`;
                ctx.beginPath();
                ctx.arc(Math.cos(gAngle) * gr, Math.sin(gAngle) * gr, 1.5 + Math.sin(Date.now() * 0.015 + i) * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }
            // Flare bursts
            for (let f = 0; f < 5; f++) {
                const fAngle = Date.now() * 0.008 + f;
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(fAngle) * radius * 2.5, Math.sin(fAngle) * radius * 2.5);
                ctx.stroke();
            }
            break;

        case 'v2_chaos':
            // Fractal chaos with recursive branches and color-shifting interference
            ctx.strokeStyle = '#ff1493';
            ctx.lineWidth = 1;
            function drawChaosFractal(len, angle, depth) {
                if (depth > 4 || len < 1) return;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const endX = Math.cos(angle) * len;
                const endY = Math.sin(angle) * len;
                ctx.lineTo(endX + Math.sin(Date.now() * 0.01 + depth) * 2, endY + Math.cos(Date.now() * 0.008 + depth) * 1.5);
                ctx.stroke();
                const hueShift = (Date.now() * 0.2 + depth * 60) % 360;
                ctx.strokeStyle = `hsl(${hueShift}, 100%, 50%)`;
                drawChaosFractal(len * 0.6, angle + 0.4, depth + 1);
                drawChaosFractal(len * 0.6, angle - 0.4, depth + 1);
                drawChaosFractal(len * 0.5, angle + Math.PI / 2, depth + 1);
            }
            for (let i = 0; i < 6; i++) {
                const baseAngle = i * Math.PI / 3;
                ctx.save();
                ctx.rotate(baseAngle);
                drawChaosFractal(radius * 1.2, 0, 0);
                ctx.restore();
            }
            break;

        case 'v2_eternal':
            // Infinite inferno with 7+ fire rings, ember storms, and heat distortion
            // Core flame
            const eternalPulse = Math.sin(Date.now() / 80) * 0.5 + 0.5;
            ctx.fillStyle = '#ff4500';
            ctx.beginPath();
            ctx.arc(0, 0, radius * eternalPulse, 0, Math.PI * 2);
            ctx.fill();
            // Multi-ring fire: 7 layers
            for (let i = 1; i < 8; i++) {
                const ringR = radius + i * 6 + Math.sin(Date.now() / (100 * i)) * 4;
                const ringAlpha = 0.4 / i;
                ctx.globalAlpha = ringAlpha;
                ctx.strokeStyle = `hsl(20, 100%, ${70 - i * 5}%)`;
                ctx.lineWidth = 4 - i * 0.5;
                ctx.beginPath();
                for (let j = 0; j < 360; j += 15) {
                    const rad = j * Math.PI / 180;
                    const flameWiggle = Math.sin(Date.now() * 0.02 + j + i) * 3;
                    const rx = Math.cos(rad) * ringR + flameWiggle;
                    const ry = Math.sin(rad) * ringR;
                    if (j === 0) ctx.moveTo(rx, ry);
                    else ctx.lineTo(rx, ry);
                }
                ctx.closePath();
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            // Ember storm: 20 random embers
            ctx.fillStyle = '#ffff00';
            for (let e = 0; e < 20; e++) {
                const ex = (Math.random() - 0.5) * radius * 2.5;
                const ey = (Math.random() - 0.5) * radius * 2.5;
                const eAlpha = Math.random() * 0.8;
                ctx.globalAlpha = eAlpha;
                ctx.beginPath();
                ctx.arc(ex, ey, 0.8 + Math.random() * 1.2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            break;
    }
    ctx.restore();
}

// --- ATTACK ARCHITECTURE (Unique Attack Registry - UAR) ---

// Base Attack Structure
function createAttack(x, y, vx, vy, color, radius, damage, lifetime = Infinity, type = 'basic') {
    return { x, y, vx, vy, color, radius, damage, lifetime, type };
}

// White Hole Mechanic (Repels attacks, harder for bigger radius)
function updateWhiteHole(dt) {
    if (!game.whiteHole) return;
    const wh = game.whiteHole;
    wh.timer -= dt;
    if (wh.timer <= 0) {
        game.whiteHole = null;
        player.skinState.whiteHoleActive = false;
        return;
    }

    // Repel nearby attacks
    game.attacks.forEach(attack => {
        const dx = attack.x - player.x;
        const dy = attack.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < wh.radius && dist > player.radius + 10) {
            const repelForce = wh.strength / (attack.radius * attack.radius + 1); // Harder for bigger
            attack.vx += (dx / dist) * repelForce * dt / 1000;
            attack.vy += (dy / dist) * repelForce * dt / 1000;
        }
    });
}

function spawnWhiteHole() {
    game.whiteHole = {
        x: player.x,
        y: player.y,
        radius: 150,
        strength: 5,
        timer: 5000 // 5 seconds
    };
    player.skinState.whiteHoleActive = true;
    showPopup('WHITE HOLE ACTIVATED! Repelling...', player.x, player.y - 50, 2000, '#ffffff');
}

// Unique Attack Functions - Extended for more uniqueness (after h different)
function spawn_H_attack() { // H: Homing Hive (Swarm with random deviations)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 8; i++) {
        const angle = i * Math.PI / 4;
        const x = cw / 2 + Math.cos(angle) * 200;
        const y = ch / 2 + Math.sin(angle) * 200;
        const vx = Math.cos(angle) * 1 + (Math.random() - 0.5) * 0.5; // Deviation
        const vy = Math.sin(angle) * 1 + (Math.random() - 0.5) * 0.5;

        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#888888', 4, 6, 6000),
            deviationTimer: 0,
            update: function(dt) {
                this.deviationTimer += dt;
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 50) {
                    this.vx += (dx / dist) * 0.003 + (Math.random() - 0.5) * 0.01 * Math.sin(this.deviationTimer / 200);
                    this.vy += (dy / dist) * 0.003 + (Math.random() - 0.5) * 0.01 * Math.sin(this.deviationTimer / 200);
                }
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_I_attack() { // I: Imploding Implosion (Pull towards random point)
    const cw = canvas.width, ch = canvas.height;
    const implodePointX = cw * (0.3 + Math.random() * 0.4);
    const implodePointY = ch * (0.3 + Math.random() * 0.4);
    for (let i = 0; i < 6; i++) {
        const angle = i * Math.PI / 3;
        const x = cw / 2 + Math.cos(angle) * 300;
        const y = ch / 2 + Math.sin(angle) * 300;

        game.attacks.push({
            ...createAttack(x, y, 0, 0, '#666666', 7, 9, 7000),
            implodePointX, implodePointY,
            update: function(dt) {
                const dx = this.implodePointX - this.x;
                const dy = this.implodePointY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 20) {
                    this.vx = (dx / dist) * 1.2;
                    this.vy = (dy / dist) * 1.2;
                }
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

// Add more unique for j-z, 0-9 (example for a few, pattern for others)
function spawn_J_attack() { // J: Jagged Javelins (Zigzag projectiles)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 5; i++) {
        const y = i * ch / 5;
        const vx = 1.5;
        const vy = (Math.random() - 0.5) * 2;

        game.attacks.push({
            ...createAttack(0, y, vx, vy, '#777777', 5, 7, 5000),
            zigzagTimer: 0,
            update: function(dt) {
                this.zigzagTimer += dt;
                this.vy += Math.sin(this.zigzagTimer / 300) * 0.02;
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

// New unique attacks for post-K
function spawn_K_attack() { // K: Nail Rain from sides/top/bottom
    const cw = canvas.width, ch = canvas.height;
    for (let side = 0; side < 4; side++) {
        let startX, startY, vx, vy;
        if (side === 0) { // left
            startX = 0; startY = Math.random() * ch; vx = 3; vy = (Math.random() - 0.5) * 1;
        } else if (side === 1) { // right
            startX = cw; startY = Math.random() * ch; vx = -3; vy = (Math.random() - 0.5) * 1;
        } else if (side === 2) { // top
            startX = Math.random() * cw; startY = 0; vx = (Math.random() - 0.5) * 1; vy = 3;
        } else { // bottom
            startX = Math.random() * cw; startY = ch; vx = (Math.random() - 0.5) * 1; vy = -3;
        }
        game.attacks.push(createAttack(startX, startY, vx, vy, '#cccccc', 2, 5, 5000)); // Thin nails
    }
}

function spawn_L_attack() { // L: Labyrinth Lines (Horizontal barriers with random gaps)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 4; i++) {
        const y = i * ch / 5;
        const gapStart = Math.random() * cw * 0.3;
        const gapEnd = gapStart + cw * 0.2;
        game.attacks.push({
            x: 0, y: y, vx: 0, vy: 2,
            color: '#ffaa00', radius: 10, damage: 12, lifetime: 6000, type: 'labyrinth',
            width: cw, height: 20, gapStart, gapEnd,
            update: function(dt) {
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            },
            draw: function(ctx) {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.7;
                ctx.fillRect(this.x, this.y, this.gapStart, this.height);
                ctx.fillRect(this.gapEnd, this.y, this.width - this.gapEnd, this.height);
                ctx.globalAlpha = 1;
            },
            isColliding: function(px, py, pr) {
                return py + pr > this.y && py - pr < this.y + this.height &&
                       ((px + pr < this.gapStart || px - pr > this.gapEnd) && px > 0 && px < this.width);
            }
        });
    }
}

function spawn_M_attack() { // M: Mirror Missiles (Bounce off walls)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 6; i++) {
        const angle = i * Math.PI / 3;
        const x = cw / 2 + Math.cos(angle) * 150;
        const y = ch / 2 + Math.sin(angle) * 150;
        const vx = Math.cos(angle) * 2;
        const vy = Math.sin(angle) * 2;

        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#aa00ff', 6, 10, 8000),
            bounces: 0,
            update: function(dt) {
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                // Bounce logic
                if (this.x < 0 || this.x > cw) {
                    this.vx = -this.vx;
                    this.bounces++;
                }
                if (this.y < 0 || this.y > ch) {
                    this.vy = -this.vy;
                    this.bounces++;
                }
                if (this.bounces > 3) this.lifetime = 0;
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_N_attack() { // N: Nova Burst (Explode on contact)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 5; i++) {
        const angle = i * Math.PI * 2 / 5;
        const x = cw / 2 + Math.cos(angle) * 250;
        const y = ch / 2 + Math.sin(angle) * 250;

        game.attacks.push({
            ...createAttack(x, y, Math.cos(angle) * 1.5, Math.sin(angle) * 1.5, '#ff00aa', 8, 0, 5000),
            fuse: 2000, // Time to explode
            update: function(dt) {
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.fuse -= dt;
                if (this.fuse <= 0) {
                    // Explode: spawn smaller projectiles
                    for (let j = 0; j < 8; j++) {
                        const expAngle = j * Math.PI / 4;
                        game.attacks.push(createAttack(this.x, this.y, Math.cos(expAngle) * 3, Math.sin(expAngle) * 3, '#ff00aa', 4, 8, 2000));
                    }
                    this.lifetime = 0;
                }
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_O_attack() { // O: Orbiting Orbs (Circle around center)
    const cw = canvas.width, ch = canvas.height;
    const centerX = cw / 2, centerY = ch / 2;
    for (let i = 0; i < 6; i++) {
        const angle = i * Math.PI / 3;
        const r = 200;
        const x = centerX + Math.cos(angle) * r;
        const y = centerY + Math.sin(angle) * r;
        const orbSpeed = 0.5;

        game.attacks.push({
            ...createAttack(x, y, 0, 0, '#00aaff', 7, 9, 10000),
            centerX, centerY, r, angle, orbSpeed,
            update: function(dt) {
                this.angle += this.orbSpeed * (dt / 16.67);
                this.x = this.centerX + Math.cos(this.angle) * this.r;
                this.y = this.centerY + Math.sin(this.angle) * this.r;
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_P_attack() { // P: Bowling Balls rolling in and out
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 3; i++) {
        const y = ch * (0.2 + i * 0.3);
        const x = -50;
        const vx = 1.5;
        const vy = 0;
        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#8B4513', 15, 20, 10000),
            state: 'in',
            update: function(dt) {
                if (this.state === 'in' && this.x > cw / 2) {
                    this.state = 'out';
                    this.vx = -this.vx * 1.2; // Speed up out
                }
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_Q_attack() { // Q: Quantum Quakes (Screen shake bursts)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 4; i++) {
        const x = Math.random() * cw;
        const y = Math.random() * ch;
        game.attacks.push({
            ...createAttack(x, y, 0, 0, '#8800ff', 20, 15, 4000),
            quakeTimer: 0,
            update: function(dt) {
                this.quakeTimer += dt;
                if (this.quakeTimer > 500) {
                    startShake(200, 4);
                    this.quakeTimer = 0;
                }
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_R_attack() { // R: Ricochet Rounds (Bounce between edges)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const x = Math.random() * cw;
        const y = Math.random() * ch;
        const speed = 2.5;

        game.attacks.push({
            ...createAttack(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, '#ff8800', 5, 7, 7000),
            bounces: 0,
            update: function(dt) {
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                if (this.x < 0 || this.x > cw) this.vx = -this.vx;
                if (this.y < 0 || this.y > ch) this.vy = -this.vy;
                this.bounces++;
                if (this.bounces > 6) this.lifetime = 0;
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_S_attack() { // S: Scatter Shot (Explode into shards)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 3; i++) {
        const x = cw / 2;
        const y = ch / 2 - 100 + i * 100;
        game.attacks.push({
            ...createAttack(x, y, 0, 2, '#ff4444', 10, 0, 3000),
            fuse: 1500,
            update: function(dt) {
                this.y += this.vy * (dt / 16.67);
                this.fuse -= dt;
                if (this.fuse <= 0) {
                    for (let j = 0; j < 12; j++) {
                        const shardAngle = j * Math.PI / 6;
                        game.attacks.push(createAttack(this.x, this.y, Math.cos(shardAngle) * 4, Math.sin(shardAngle) * 4, '#ff4444', 3, 6, 2000));
                    }
                    this.lifetime = 0;
                }
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_T_attack() { // T: Tornado Twist (Spiraling inward)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 10; i++) {
        const angle = i * Math.PI / 5;
        const x = cw / 2 + Math.cos(angle) * 300;
        const y = ch / 2 + Math.sin(angle) * 300;

        game.attacks.push({
            ...createAttack(x, y, -Math.cos(angle) * 1, -Math.sin(angle) * 1, '#44ff44', 4, 5, 6000),
            twistAngle: angle,
            twistSpeed: 0.002,
            update: function(dt) {
                this.twistAngle += this.twistSpeed * dt;
                const r = Math.sqrt((this.x - cw/2)**2 + (this.y - ch/2)**2) * 0.995; // Spiral in
                this.x = cw / 2 + Math.cos(this.twistAngle) * r;
                this.y = ch / 2 + Math.sin(this.twistAngle) * r;
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_U_attack() { // U: Undulating Waves (Sine wave projectiles)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 5; i++) {
        const y = i * ch / 6;
        game.attacks.push({
            ...createAttack(0, y, 2, 0, '#44aaff', 6, 8, 5000),
            waveTimer: Math.random() * 1000,
            update: function(dt) {
                this.waveTimer += dt;
                this.y += Math.sin(this.waveTimer / 400) * 0.5;
                this.x += this.vx * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_V_attack() { // V: Vortex Pull (Attract to center)
    const cw = canvas.width, ch = canvas.height;
    const centerX = cw / 2, centerY = ch / 2;
    for (let i = 0; i < 7; i++) {
        const angle = i * Math.PI * 2 / 7;
        const x = centerX + Math.cos(angle) * 250;
        const y = centerY + Math.sin(angle) * 250;

        game.attacks.push({
            ...createAttack(x, y, 0, 0, '#aa44ff', 5, 7, 7000),
            centerX, centerY,
            update: function(dt) {
                const dx = this.centerX - this.x;
                const dy = this.centerY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 30) {
                    this.vx = (dx / dist) * 1.5;
                    this.vy = (dy / dist) * 1.5;
                }
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_W_attack() { // W: Fast wall with gaps - FIXED: span entire screen
    const cw = canvas.width, ch = canvas.height;
    const wallSpeed = 4;
    game.attacks.push({
        x: 0, y: -20, vx: 0, vy: wallSpeed,
        color: '#f00', radius: 10, damage: 15, lifetime: 3000, type: 'wall',
        width: cw, height: 20, gapStart: cw * 0.1, gapEnd: cw * 0.3, // FIXED: width = cw
        update: function(dt) {
            this.y += this.vy * (dt / 16.67);
            this.lifetime -= dt;
        },
        draw: function(ctx) {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = 0.7;
            ctx.fillRect(this.x, this.y, this.gapStart, this.height);
            ctx.fillRect(this.gapEnd, this.y, this.width - this.gapEnd, this.height);
            ctx.globalAlpha = 1;
        },
        isColliding: function(px, py, pr) {
            return py + pr > this.y && py - pr < this.y + this.height &&
                   ((px + pr < this.gapStart || px - pr > this.gapEnd) && px > 0 && px < this.width);
        }
    });
}

function spawn_X_attack() { // X: Crossfire (X-shaped lasers)
    const cw = canvas.width, ch = canvas.height;
    const centerX = cw / 2, centerY = ch / 2;
    const laserLength = Math.max(cw, ch) * 1.5;
    const thickness = 8;

    // Horizontal laser
    game.attacks.push({
        x: centerX, y: centerY, vx: 0, vy: 0,
        color: '#ff0000', radius: thickness / 2, damage: 12, lifetime: 5000, type: 'crossfire',
        width: laserLength, height: thickness, angle: 0,
        update: function(dt) {
            this.lifetime -= dt;
        },
        draw: function(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            ctx.fillStyle = this.color;
            ctx.globalAlpha = 0.6;
            ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
            ctx.globalAlpha = 1;
            ctx.restore();
        },
        isColliding: function(px, py, pr) {
            const dx = px - this.x;
            const dy = py - this.y;
            const cosA = Math.cos(-this.angle), sinA = Math.sin(-this.angle);
            const rotatedX = dx * cosA + dy * sinA;
            const rotatedY = -dx * sinA + dy * cosA;
            const halfW = this.width / 2, halfH = this.height / 2;
            return Math.abs(rotatedY) < halfH + pr && Math.abs(rotatedX) < halfW + pr;
        }
    });

    // Vertical laser
    game.attacks.push({
        x: centerX, y: centerY, vx: 0, vy: 0,
        color: '#ff0000', radius: thickness / 2, damage: 12, lifetime: 5000, type: 'crossfire',
        width: thickness, height: laserLength, angle: Math.PI / 2,
        update: game.attacks[game.attacks.length - 1].update,
        draw: game.attacks[game.attacks.length - 1].draw,
        isColliding: game.attacks[game.attacks.length - 1].isColliding
    });
}

function spawn_Y_attack() { // Y: Yielding Yield (Slow expanding ring)
    const cw = canvas.width, ch = canvas.height;
    const centerX = cw / 2, centerY = ch / 2;
    game.attacks.push({
        x: centerX, y: centerY, vx: 0, vy: 0,
        color: '#ffff00', radius: 10, damage: 10, lifetime: 8000, type: 'ring',
        ringRadius: 10,
        update: function(dt) {
            this.ringRadius += 1 * (dt / 16.67);
            this.lifetime -= dt;
        },
        draw: function(ctx) {
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 5;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.ringRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        },
        isColliding: function(px, py, pr) {
            const dist = Math.sqrt((px - this.x)**2 + (py - this.y)**2);
            return dist < this.ringRadius + pr && dist > this.ringRadius - 20;
        }
    });
}

function spawn_Z_attack() { // Z: Zonal Collapse (Zig-zag)
    const cw = canvas.width, ch = canvas.height;
    const count = 5;
    for (let i = 0; i < count; i++) {
        const x = cw / 2;
        const y = ch / 2;
        const angle = (Math.PI * 2 / count) * i;
        const vx = Math.cos(angle) * 3;
        const vy = Math.sin(angle) * 3;

        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#00ffcc', 6, 15, 6000),
            state: 0, // 0: out, 1: zig-zag in
            maxDist: 300,
            update: function(dt) {
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                const distFromCenter = Math.sqrt((this.x - cw / 2)**2 + (this.y - ch / 2)**2);

                if (distFromCenter > this.maxDist && this.state === 0) {
                    this.state = 1;
                }
                if (this.state === 1) {
                    // Zig-zag back towards center
                    this.vx = (cw / 2 - this.x) * 0.002 * Math.sin(Date.now() / 200);
                    this.vy = (ch / 2 - this.y) * 0.002 * Math.cos(Date.now() / 200);
                }
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_0_attack() { // 0: Orbiting Orbit (Counter-clockwise)
    const cw = canvas.width, ch = canvas.height;
    const centerX = cw / 2, centerY = ch / 2;
    for (let i = 0; i < 5; i++) {
        const angle = i * Math.PI * 2 / 5;
        const r = 180;
        const x = centerX + Math.cos(angle) * r;
        const y = centerY + Math.sin(angle) * r;
        const orbSpeed = -0.8; // Counter-clockwise

        game.attacks.push({
            ...createAttack(x, y, 0, 0, '#ffaa00', 8, 12, 9000),
            centerX, centerY, r, angle, orbSpeed,
            update: function(dt) {
                this.angle += this.orbSpeed * (dt / 16.67);
                this.x = this.centerX + Math.cos(this.angle) * this.r;
                this.y = this.centerY + Math.sin(this.angle) * this.r;
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_1_attack() { // 1: Linear Lance (Straight fast lines)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 4; i++) {
        const y = ch * 0.25 + i * ch * 0.2;
        game.attacks.push({
            ...createAttack(0, y, 4, 0, '#ff0000', 3, 8, 4000),
            update: function(dt) {
                this.x += this.vx * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_2_attack() { // 2: Curved Crescent (Arcing paths)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 6; i++) {
        const angle = i * Math.PI / 3;
        const x = 0;
        const y = ch / 2 + Math.sin(angle) * 100;
        const vx = 2;
        const vy = Math.cos(angle) * 1;

        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#00ff00', 5, 6, 6000),
            arcTimer: 0,
            update: function(dt) {
                this.arcTimer += dt;
                this.vy = Math.sin(this.arcTimer / 500) * 2;
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_3_attack() { // 3: Triple Threat (Three waves)
    const cw = canvas.width, ch = canvas.height;
    for (let wave = 0; wave < 3; wave++) {
        for (let i = 0; i < 3; i++) {
            const x = cw / 2;
            const y = ch / 2 + (i - 1) * 50 + wave * 200;
            game.attacks.push({
                ...createAttack(x, y, wave * -1.5 + (Math.random() - 0.5), 0, '#00aaff', 6, 9, 5000),
                update: function(dt) {
                    this.x += this.vx * (dt / 16.67);
                    this.y += this.vy * (dt / 16.67);
                    this.lifetime -= dt;
                }
            });
        }
    }
}

function spawn_4_attack() { // 4: Fourfold Fork (Split mid-way)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 4; i++) {
        const angle = i * Math.PI / 2;
        const x = cw / 2 + Math.cos(angle) * 200;
        const y = ch / 2 + Math.sin(angle) * 200;
        const vx = -Math.cos(angle) * 1.5;
        const vy = -Math.sin(angle) * 1.5;
        const splitDist = 100;

        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#aaff00', 5, 0, 6000),
            distTraveled: 0,
            update: function(dt) {
                this.distTraveled += Math.sqrt(this.vx**2 + this.vy**2) * (dt / 16.67);
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                if (this.distTraveled > splitDist) {
                    // Split into two
                    for (let j = -1; j <= 1; j += 2) {
                        const splitVx = this.vx + j * 1;
                        const splitVy = this.vy + j * 1;
                        game.attacks.push(createAttack(this.x, this.y, splitVx, splitVy, this.color, this.radius, this.damage, 3000));
                    }
                    this.lifetime = 0;
                }
                this.lifetime -= dt;
            }
        });
    }
}

// Additional unique for numbers
function spawn_5_attack() { // 5: Pentagon Pulse (5-sided bounce)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 5; i++) {
        const angle = i * Math.PI * 2 / 5;
        const x = cw / 2 + Math.cos(angle) * 150;
        const y = ch / 2 + Math.sin(angle) * 150;
        const speed = 2;

        game.attacks.push({
            ...createAttack(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, '#ffaa44', 7, 10, 7000),
            sides: 5,
            update: function(dt) {
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                // Bounce on edges
                if (this.x < 0 || this.x > cw) this.vx = -this.vx;
                if (this.y < 0 || this.y > ch) this.vy = -this.vy;
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_6_attack() { // 6: Hexagon Hive (6 orbs)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 6; i++) {
        const angle = i * Math.PI / 3;
        const x = cw / 2 + Math.cos(angle) * 180;
        const y = ch / 2 + Math.sin(angle) * 180;

        game.attacks.push({
            ...createAttack(x, y, -Math.cos(angle) * 1.2, -Math.sin(angle) * 1.2, '#44ffaa', 6, 8, 6000),
            update: function(dt) {
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_7_attack() { // 7: Lucky Seven (7 random directions)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 7; i++) {
        const angle = Math.random() * Math.PI * 2;
        const edge = Math.random() * 4;
        let x, y;
        if (edge < 1) { x = Math.random() * cw; y = 0; }
        else if (edge < 2) { x = Math.random() * cw; y = ch; }
        else if (edge < 3) { x = 0; y = Math.random() * ch; }
        else { x = cw; y = Math.random() * ch; }

        const speed = 2 + Math.random();
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;

        game.attacks.push(createAttack(x, y, vx, vy, '#ff44aa', 5, 7, 5000));
    }
}

function spawn_8_attack() { // 8: Infinity Loop (Figure 8 path)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 4; i++) {
        const startAngle = i * Math.PI / 2;
        const x = cw / 2 + Math.sin(startAngle) * 100;
        const y = ch / 2 + Math.cos(startAngle) * 100;
        game.attacks.push({
            ...createAttack(x, y, 0, 1.5, '#aa44ff', 6, 9, 8000),
            loopTimer: startAngle * 1000,
            update: function(dt) {
                this.loopTimer += dt;
                this.x = cw / 2 + Math.sin(this.loopTimer / 800) * 100;
                this.y = ch / 2 + Math.sin(this.loopTimer / 400) * 50; // Figure 8
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_9_attack() { // 9: Ninefold Nova (9 bursts)
    const cw = canvas.width, ch = canvas.height;
    for (let burst = 0; burst < 3; burst++) {
        setTimeout(() => {
            for (let i = 0; i < 3; i++) {
                const angle = (i + burst * 3) * Math.PI / 3;
                const x = cw / 2 + Math.cos(angle) * 200;
                const y = ch / 2 + Math.sin(angle) * 200;
                game.attacks.push(createAttack(x, y, -Math.cos(angle) * 2.5, -Math.sin(angle) * 2.5, '#ff4400', 4, 12, 3000));
            }
        }, burst * 1000);
    }
}

// Unique for Escape: Teleport traps (sudden position swaps)
function spawn_Escape_attack() { // Escape: Teleport Traps (Random reposition every second)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 6; i++) {
        const x = Math.random() * cw;
        const y = Math.random() * ch;
        game.attacks.push({
            ...createAttack(x, y, 0, 0, '#purple', 12, 18, 10000),
            teleportTimer: 0,
            lastX: x, lastY: y,
            update: function(dt) {
                this.teleportTimer += dt;
                if (this.teleportTimer > 1000) {
                    this.lastX = this.x;
                    this.lastY = this.y;
                    this.x = Math.random() * cw;
                    this.y = Math.random() * ch;
                    this.teleportTimer = 0;
                    startShake(100, 2);
                }
                this.lifetime -= dt;
            },
            draw: function(ctx) {
                // Draw trail from last position
                ctx.strokeStyle = 'rgba(128, 0, 128, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.lastX, this.lastY);
                ctx.lineTo(this.x, this.y);
                ctx.stroke();
                // Draw current
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }
}

// Unique Attack Functions - World 2 Examples
function spawn_Enter_attack() { // Enter: The Hard Commit (Vertical Beams)
    const cw = canvas.width, ch = canvas.height;
    // Create large, slow moving vertical beams
    for (let i = 0; i < 3; i++) {
        const x = cw / 4 + i * cw / 4;
        const width = 30;
        const speed = 0.5;

        game.attacks.push({
            x: x, y: -ch / 2, vx: 0, vy: speed,
            color: '#ff6600', radius: width / 2, damage: 30, lifetime: 10000, type: 'beam',
            width: width, height: ch * 2,
            update: function(dt) {
                this.y += this.vy * (dt / 16.67);
                this.vy += 0.001; // Gravity effect
                if (this.y > ch + ch / 2) this.lifetime = 0;
            },
            draw: function(ctx) {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.5;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                ctx.globalAlpha = 1;
            },
            isColliding: function(px, py, pr) {
                // Check AABB collision
                return px + pr > this.x - this.width / 2 &&
                       px - pr < this.x + this.width / 2 &&
                       py + pr > this.y - this.height / 2 &&
                       py - pr < this.y + this.height / 2;
            }
        });
    }
}

function spawn_ArrowRight_attack() { // ArrowRight: Directional Current
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 10; i++) {
        const x = cw * 0.1;
        const y = Math.random() * ch;
        const speed = 1 + Math.random();

        game.attacks.push({
            ...createAttack(x, y, speed, 0, '#00bfff', 5, 5, 8000),
            baseVx: speed,
            update: function(dt) {
                // Persistent force field pushes right
                this.vx = this.baseVx + 0.1 * (dt / 16.67);
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                if (this.x > cw + 100) this.lifetime = 0;
                this.lifetime -= dt;
            }
        });
    }
}

// Spike Attack (from diep.io: spinning spiked orbs)
function spawn_Spike_attack() { // For '0' or symbols
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 4; i++) {
        const angle = i * Math.PI / 2;
        const x = cw / 2 + Math.cos(angle) * 250;
        const y = ch / 2 + Math.sin(angle) * 250;

        game.attacks.push({
            ...createAttack(x, y, Math.cos(angle) * 1.2, Math.sin(angle) * 1.2, '#8B4513', 12, 15, 9000),
            rotation: 0,
            spikes: 8, // Number of spikes
            update: function(dt) {
                this.rotation += dt * 0.005; // Spin
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            },
            draw: function(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                // Core
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                // Spikes
                ctx.fillStyle = '#654321';
                for (let s = 0; s < this.spikes; s++) {
                    const sAngle = s * Math.PI * 2 / this.spikes;
                    ctx.beginPath();
                    ctx.moveTo(this.radius * 0.6 * Math.cos(sAngle), this.radius * 0.6 * Math.sin(sAngle));
                    ctx.lineTo(this.radius * Math.cos(sAngle), this.radius * Math.sin(sAngle));
                    ctx.lineTo(this.radius * 0.8 * Math.cos(sAngle + Math.PI / this.spikes), this.radius * 0.8 * Math.sin(sAngle + Math.PI / this.spikes));
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.restore();
            }
        });
    }
}

function spawn_Exclaim_attack() { // !: Flashing ! then red box - FIXED: random spot
    const cw = canvas.width, ch = canvas.height;
    const randX = Math.random() * (cw - 100) + 50;
    const randY = Math.random() * (ch - 100) + 50;
    game.attacks.push({
        x: randX, y: randY, vx: 0, vy: 0,
        color: '#fff', radius: 0, damage: 0, lifetime: 3000, type: 'exclaim',
        state: 'flash', flashTimer: 0, boxTimer: 0,
        update: function(dt) {
            this.flashTimer += dt;
            if (this.state === 'flash' && this.flashTimer > 1000) {
                this.state = 'box';
                this.boxTimer = 0;
                this.damage = 25; // Damage on box
            }
            if (this.state === 'box') {
                this.boxTimer += dt;
                if (this.boxTimer > 1000) this.lifetime = 0;
            }
            this.lifetime -= dt;
        },
        draw: function(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            if (this.state === 'flash') {
                const alpha = Math.sin(this.flashTimer / 50) * 0.5 + 0.5;
                ctx.globalAlpha = alpha;
                ctx.font = 'bold 40px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('!', 0, 0);
            } else {
                const alpha = 1 - this.boxTimer / 1000;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#f00';
                ctx.fillRect(-20, -20, 40, 40);
            }
            ctx.restore();
        },
        isColliding: function(px, py, pr) {
            const dist = Math.sqrt((px - this.x)**2 + (py - this.y)**2);
            return dist < 25 && this.state === 'box';
        }
    });
}

function spawn_A_attack() { // A: Accelerating Aperture (Homing to Center)
    const cw = canvas.width, ch = canvas.height;
    for (let i = 0; i < 4; i++) {
        const angle = i * Math.PI / 2;
        const x = cw / 2 + Math.cos(angle) * 300;
        const y = ch / 2 + Math.sin(angle) * 300;
        const vx = Math.cos(angle) * 0.5;
        const vy = Math.sin(angle) * 0.5;

        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#ff0000', 8, 10, 8000),
            update: function(dt) {
                // Accelerate towards center
                const dx = cw / 2 - this.x;
                const dy = ch / 2 - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 100) {
                    this.vx += (dx / dist) * 0.005;
                    this.vy += (dy / dist) * 0.005;
                }
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_B_attack() { // B: Straight-line Stream (Fixed Trajectory)
    const cw = canvas.width, ch = canvas.height;
    const speed = 2.0;

    // Spawn 6 projectiles from random locations near the edge
    for (let i = 0; i < 6; i++) {
        let x, y;
        // Determine if spawning from horizontal (top/bottom) or vertical (left/right) edges
        if (Math.random() < 0.5) { 
            x = Math.random() * cw;
            y = Math.random() < 0.5 ? 0 : ch;
        } else { 
            x = Math.random() < 0.5 ? 0 : cw;
            y = Math.random() * ch;
        }

        // Calculate straight trajectory towards player's current position (snapshot at spawn)
        const dx = player.x - x;
        const dy = player.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        const vx = (dx / dist) * speed;
        const vy = (dy / dist) * speed;

        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#ff9900', 7, 8, 8000),
            // Minimal update: just handle the lifetime. vx/vy remain constant.
            update: function(dt) {
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_C_attack() { // C: Angular Sweep (Rotating Laser Grid)
    const cw = canvas.width, ch = canvas.height;
    const center_x = cw / 2;
    const center_y = ch / 2;
    const count = 2; // Reduced to 2 beams for better balance
    const thickness = 10;
    const angularSpeed = 0.0005; // radians per millisecond (slow rotation)

    for (let i = 0; i < count; i++) {
        const initialAngle = i * Math.PI / count; // 0 and PI (180 deg)
        const laserLength = Math.max(cw, ch) * 2;

        game.attacks.push({
            x: center_x, 
            y: center_y,
            vx: 0, 
            vy: 0,
            color: '#ff00cc', 
            radius: thickness / 2, 
            damage: 10, 
            lifetime: 15000, 
            type: 'laser',
            width: thickness, 
            length: laserLength,
            angle: initialAngle,
            
            update: function(dt) {
                // Rotate the laser line
                this.angle += angularSpeed * dt;
                this.lifetime -= dt;
            },
            
            draw: function(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Draw beam as a long, centered rectangle
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.6;
                ctx.fillRect(-this.length / 2, -this.width / 2, this.length, this.width);
                ctx.globalAlpha = 1;
                
                // Draw a pulsing core effect
                const coreRadius = this.width / 2;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, 0, coreRadius * (1 + Math.sin(Date.now() / 100) * 0.2), 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            },
            
            isColliding: function(px, py, pr) {
                // Check if the player is within the rotating beam area
                const dx = px - this.x;
                const dy = py - this.y;
                
                // Inverse rotation of player coordinates
                const cosA = Math.cos(-this.angle);
                const sinA = Math.sin(-this.angle);
                
                const rotatedY = dx * sinA + dy * cosA;
                
                // Check collision only against the width of the beam
                const halfWidth = this.width / 2;
                
                return rotatedY + pr > -halfWidth && rotatedY - pr < halfWidth;
            }
        });
    }
}

function spawn_D_attack() { // D: Drift Net (Slow, Wide Swarm - 1 Damage)
    const cw = canvas.width, ch = canvas.height;
    const count = 15; // High projectile count
    const speed = 0.8; // Slow speed

    for (let i = 0; i < count; i++) {
        // Spawn across the entire height of the screen, slightly off-screen left
        // Add a slight random offset to y for a less rigid pattern
        const yOffset = (Math.random() - 0.5) * 40;
        const x = -50;
        const y = (i / count) * ch + yOffset;

        game.attacks.push({
            ...createAttack(x, y, speed, 0, '#0099ff', 4, 1, 10000), // Damage set to 1
            update: function(dt) {
                // No change in trajectory, just lifetime
                this.lifetime -= dt;
            }
        });
    }
}

// --- NEW ATTACKS: E and F ---

function spawn_E_attack() { // E: Echo Wave (Oscillating Corridors)
    const cw = canvas.width, ch = canvas.height;
    const waveWidth = 40; // Slightly narrower walls

    // 1. Create two oscillating barrier attacks (non-damaging walls)
    // Wall 1 (Left)
    game.attacks.push({
        x: cw / 4, y: ch / 2, vx: 0, vy: 0,
        color: '#ff66b2', radius: waveWidth / 2, damage: 0, lifetime: 8000, type: 'oscillator',
        width: waveWidth, height: ch, start_x: cw/4, amplitude: cw/8,
        update: function(dt) {
            // Horizontal sine wave oscillation
            this.x = this.start_x + Math.sin(Date.now() / 800) * this.amplitude;
            this.lifetime -= dt;
        },
        draw: function(ctx) {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = 0.2; // Very transparent
            ctx.fillRect(this.x - this.width / 2, 0, this.width, this.height);
            // Draw visible lines
            ctx.strokeStyle = this.color;
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 1;
            ctx.strokeRect(this.x - this.width / 2, 0, this.width, this.height);
            ctx.globalAlpha = 1;
        },
        isColliding: function(px, py, pr) {
            // Check collision with player
            return px + pr > this.x - this.width / 2 &&
                   px - pr < this.x + this.width / 2;
        }
    });

    // Wall 2 (Right)
    game.attacks.push({
        x: cw * 3 / 4, y: ch / 2, vx: 0, vy: 0,
        color: '#ff66b2', radius: waveWidth / 2, damage: 0, lifetime: 8000, type: 'oscillator',
        width: waveWidth, height: ch, start_x: cw*3/4, amplitude: cw/8,
        update: function(dt) {
            this.x = this.start_x + Math.sin(Date.now() / 800) * this.amplitude;
            this.lifetime -= dt;
        },
        // Re-use draw and collision logic from Wall 1
        draw: game.attacks[game.attacks.length-1].draw,
        isColliding: game.attacks[game.attacks.length-1].isColliding
    });
    
    // 2. Create small, low-damage projectiles that move across the screen (The real threat)
    for (let i = 0; i < 6; i++) {
        const x = cw * (0.1 + i * 0.15);
        const y = ch / 2;
        const speed = 1.2 + Math.random();

        game.attacks.push({
            ...createAttack(x, y, 0, speed, '#fff', 5, 8, 8000), // Moderate damage
            update: function(dt) {
                // Reverse direction when hitting top/bottom
                if (this.y < 0 || this.y > ch) {
                    this.vy *= -1;
                }
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_F_attack() { // F: Focal Point Grid (Converge and Burst)
    const cw = canvas.width, ch = canvas.height;
    // Random focus point, far enough from edges
    const focusX = cw * (0.3 + Math.random() * 0.4); 
    const focusY = ch * (0.3 + Math.random() * 0.4);
    const speed = 1.5;

    for (let i = 0; i < 8; i++) {
        // Spawn from random edges
        let x, y;
        const edge = Math.floor(Math.random() * 4); // 0=Top, 1=Bottom, 2=Left, 3=Right
        if (edge === 0) { x = Math.random() * cw; y = 0; }
        else if (edge === 1) { x = Math.random() * cw; y = ch; }
        else if (edge === 2) { x = 0; y = Math.random() * ch; }
        else { x = cw; y = Math.random() * ch; }
        
        // Calculate initial velocity towards the focus point
        const dx = focusX - x;
        const dy = focusY - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        const vx = (dx / dist) * speed;
        const vy = (dy / dist) * speed;

        game.attacks.push({
            ...createAttack(x, y, vx, vy, '#00ffff', 6, 12, 12000), // Medium-high damage
            focusX: focusX,
            focusY: focusY,
            state: 'inbound', // 'inbound' or 'outbound'
            update: function(dt) {
                if (this.state === 'inbound') {
                    const distToFocus = Math.sqrt((this.x - this.focusX)**2 + (this.y - this.focusY)**2);
                    if (distToFocus < 20) { // Near focus point - trigger burst
                        this.state = 'outbound';
                        // Calculate new velocity (burst outwards from focus)
                        const angle = Math.atan2(this.y - this.focusY, this.x - this.focusX) + (Math.random() - 0.5) * 0.5;
                        this.vx = Math.cos(angle) * speed * 2; // Double speed on burst
                        this.vy = Math.sin(angle) * speed * 2;
                        // Draw a visual burst cue
                        startShake(100, 3);
                        showPopup('BURST!', this.focusX, this.focusY, 200, '#ff0000');
                    }
                }
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

function spawn_G_attack() { // G: Spiral Gale (Spiraling Projectiles)
    const cw = canvas.width, ch = canvas.height;
    const numProjectiles = 12;
    const baseRadius = 200;
    const baseSpeed = 1.5;

    for (let i = 0; i < numProjectiles; i++) {
        const angle = i * (Math.PI * 2 / numProjectiles);
        const x = cw / 2 + Math.cos(angle) * baseRadius;
        const y = ch / 2 + Math.sin(angle) * baseRadius;
        const speed = baseSpeed + (i / numProjectiles) * 0.5; // Slight speed variation

        game.attacks.push({
            ...createAttack(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, '#00ff88', 6, 8, 8000),
            initialAngle: angle,
            spiralSpeed: 0.0005, // Spiral inward slowly
            update: function(dt) {
                this.initialAngle += this.spiralSpeed * dt;
                this.vx = Math.cos(this.initialAngle) * speed;
                this.vy = Math.sin(this.initialAngle) * speed;
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}

const UNIQUE_ATTACK_REGISTRY = {
    // World 1 Unique Attacks (Extended for uniqueness - FIXED: more varied)
    'a': spawn_A_attack,
    'b': spawn_B_attack,
    'c': spawn_C_attack, 
    'd': spawn_D_attack,
    'e': spawn_E_attack,
    'f': spawn_F_attack,
    'g': spawn_G_attack,
    'h': spawn_H_attack,
    'i': spawn_I_attack,
    'j': spawn_J_attack,
    'k': spawn_K_attack,
    'l': spawn_L_attack, // New unique
    'm': spawn_M_attack, // New unique
    'n': spawn_N_attack, // New unique
    'o': spawn_O_attack, // New unique
    'p': spawn_P_attack,
    'q': spawn_Q_attack, // New unique
    'r': spawn_R_attack, // New unique
    's': spawn_S_attack, // New unique
    't': spawn_T_attack, // New unique
    'u': spawn_U_attack, // New unique
    'v': spawn_V_attack, // New unique
    'w': spawn_W_attack,
    'x': spawn_X_attack, // New unique
    'y': spawn_Y_attack, // New unique
    'z': spawn_Z_attack,
    '0': spawn_0_attack, // New unique
    '1': spawn_1_attack, // New unique
    '2': spawn_2_attack, // New unique
    '3': spawn_3_attack, // New unique
    '4': spawn_4_attack, // New unique
    '5': spawn_5_attack, // New unique
    '6': spawn_6_attack, // New unique
    '7': spawn_7_attack, // New unique
    '8': spawn_8_attack, // New unique
    '9': spawn_9_attack, // New unique
    
    // World 2 Unique Attacks
    'Enter': spawn_Enter_attack,
    'ArrowRight': spawn_ArrowRight_attack,
    'Escape': spawn_Escape_attack, // FIXED: Unique for Escape
    '!': spawn_Exclaim_attack,
    
    // NOTE: Fallback now varies by key for more difference
};

function spawnPatternForStage(stageKey) {
    const key = stageKey.toLowerCase();
    // Check if a unique attack is defined
    if (UNIQUE_ATTACK_REGISTRY[key]) {
        UNIQUE_ATTACK_REGISTRY[key]();
        return;
    }
    // Special for Unicode - FIXED: More varied, random spots
    if (WORLD2_UNICODE.includes(stageKey)) {
        const hash = stageKey.charCodeAt(0) % 8; // More options
        const cw = canvas.width, ch = canvas.height;
        const randX = Math.random() * (cw - 100) + 50;
        const randY = Math.random() * (ch - 100) + 50;
        switch (hash) {
            case 0: 
                // Random spike
                game.attacks.push(createAttack(randX, randY, 0, 0, '#8B4513', 12, 15, 5000)); 
                break;
            case 1: spawn_K_attack(); break;
            case 2: spawn_P_attack(); break;
            case 3: spawn_W_attack(); break;
            case 4: 
                // Random homing
                for (let i = 0; i < 3; i++) {
                    game.attacks.push(createAttack(randX + (Math.random()-0.5)*100, randY + (Math.random()-0.5)*100, 0, 0, '#ff00ff', 5, 7, 4000));
                }
                break;
            case 5: 
                // Random wall segment
                game.attacks.push({
                    x: randX, y: 0, vx: 0, vy: 3, color: '#00ff00', radius: 10, damage: 10, lifetime: 3000, type: 'segment',
                    width: 80, height: 20,
                    update: function(dt) { this.y += this.vy * (dt / 16.67); this.lifetime -= dt; },
                    draw: function(ctx) { ctx.fillStyle = this.color; ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height); },
                    isColliding: function(px, py, pr) { return py + pr > this.y && py - pr < this.y + this.height && Math.abs(px - this.x) < this.width/2 + pr; }
                });
                break;
            case 6: spawn_L_attack(); break;
            case 7: spawn_M_attack(); break;
        }
        return;
    }
    // Enhanced Fallback: Vary by key hash for different patterns
    const hash = key.charCodeAt(0) % 5;
    const cw = canvas.width, ch = canvas.height;
    const count = 4 + hash * 2; // Vary count
    const speed = 1 + hash * 0.5; // Vary speed
    const color = `hsl(${hash * 72}, 100%, 50%)`; // Vary color
    for (let i = 0; i < count; i++) {
        const angle = i * Math.PI * 2 / count + hash * 0.5;
        const x = cw / 2 + Math.cos(angle) * (200 + hash * 50);
        const y = ch / 2 + Math.sin(angle) * (200 + hash * 50);
        
        game.attacks.push({
            ...createAttack(x, y, 0, 0, color, 5 + hash, 5 + hash, 5000 + hash * 1000),
            update: function(dt) {
                // Vary homing strength
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const homing = 0.002 + hash * 0.001;
                this.vx = (dx / dist) * speed * (1 - hash * 0.1); 
                this.vy = (dy / dist) * speed * (1 - hash * 0.1);
                this.x += this.vx * (dt / 16.67);
                this.y += this.vy * (dt / 16.67);
                this.lifetime -= dt;
            }
        });
    }
}


// --- GAME FLOW AND STATE MANAGEMENT ---

function showMenu() {
    // Stop the game loop
    if (game.animationFrameId) {
        cancelAnimationFrame(game.animationFrameId);
        game.animationFrameId = null;
    }
    
    // Reset state and hide HUD/Canvas elements
    game.mode = 'menu';
    
    // Hide all game-related UI
    hud.classList.add('hidden');
    canvas.style.display = 'none';

    // Show menu UI
    menu.classList.remove('hidden');
    gameover.classList.add('hidden');
    shop.classList.add('hidden');
    
    const mainButtons = document.getElementById('main-menu-buttons');
    const shopBtn = document.getElementById('skinsShopBtn');
    if (game.inChoiceMode) {
        mainButtons.classList.add('hidden');
        keypad.classList.remove('hidden');
        shopBtn.style.display = 'none';
        buildKeypad();
    } else {
        mainButtons.classList.remove('hidden');
        keypad.classList.add('hidden');
        shopBtn.style.display = 'block';
    }

    updateHUD();
}

function startGame(mode, world, stageKey) {
    if (mode === 'precoded-uni' && !progress.world1) { // Check for world 1 completion
        startShake(300, 8);
        showPopup('World 2 Locked: Complete World 1 first!', canvas.width / 2, canvas.height / 2, 2000, '#f55');
        return;
    }

    game.mode = mode;
    game.world = world;
    game.stageKey = stageKey;
    game.timer = 8 + Math.random() * 4; // Reset timer
    player.hp = player.maxHp;
    player.shield = 0;
    player.dead = false;
    game.attacks = [];
    game.lastSpawnTime = 0;
    // Set spawn interval based on stage
    if (stageKey === '!') {
        game.spawnInterval = 200; // Every 0.2s for !
    } else {
        game.spawnInterval = 1000; // Default
    }
    game.lastTime = performance.now();

    // Reset player position to center of the canvas
    player.x = canvas.width / 2;
    player.y = canvas.height / 2;

    // Periodic Table skin logic on spawn
    if (player.equippedSkinId === 'periodic') {
        player.skinState.periodicElement = getRandomPeriodicElement();
    }

    // Hide menus and show game elements
    menu.classList.add('hidden');
    gameover.classList.add('hidden');
    hud.classList.remove('hidden');
    canvas.style.display = 'block';
    
    // Update HUD now that game state is set
    updateHUD();

    // Start the loop
    if (!game.animationFrameId) {
        game.animationFrameId = requestAnimationFrame(mainLoop);
    }
}

function nextStage() {
    const keyset = game.mode === 'yourchoice' ? game.keyset : (game.world === 'world1' ? WORLD1_KEYS : WORLD2_FULL);
    game.stageIndex++;

    if (game.stageIndex >= keyset.length) {
        // World completion logic
        if (game.world === 'world1') {
            progress.world1 = true;
            progress.unlockedKeys = [...progress.unlockedKeys, ...WORLD1_KEYS];
            showPopup('WORLD 1 CLEARED! World 2 Unlocked!', canvas.width / 2, canvas.height / 2, 3000, '#00ff44');
        } else if (game.world === 'world2') {
            progress.world2 = true;
            showPopup('WORLD 2 CLEARED! You Win!', canvas.width / 2, canvas.height / 2, 3000, '#00ff44');
        } else if (game.mode === 'yourchoice') {
            showPopup('FULL PROGRESSION CLEARED! Master of Keys!', canvas.width / 2, canvas.height / 2, 3000, '#00ff44');
        }
        
        saveProgress();
        game.inChoiceMode = false;
        showMenu(); // Return to menu after world completion
        return;
    }

    game.stageKey = keyset[game.stageIndex];
    game.timer = 8 + Math.random() * 4;
    game.attacks = [];
    game.lastSpawnTime = 0;
    // Update spawn interval
    if (game.stageKey === '!') {
        game.spawnInterval = 200;
    } else {
        game.spawnInterval = 1000;
    }
    
    // Reset player position to center
    player.x = canvas.width / 2;
    player.y = canvas.height / 2;

    // Periodic Table skin logic on wave completion
    if (player.equippedSkinId === 'periodic') {
        player.skinState.periodicElement = getRandomPeriodicElement();
    }
    
    updateHUD();
}

function gameWin() {
    // 1. Credit Calculation
    const hpRatio = player.hp / player.maxHp;
    const creditsGained = BASE_CREDITS + Math.floor(hpRatio * BONUS_CREDITS);
    player.credits += creditsGained;
    showPopup(`+${creditsGained} Credits!`, canvas.width / 2, canvas.height / 2 + 50, 1500, '#ffeb3b');

    // 2. Full health and shield regeneration (Requested feature)
    player.hp = player.maxHp;
    player.shield = player.maxShield;
    showPopup('System Refreshed: HP & Shield Maxed!', canvas.width / 2, canvas.height / 2 - 50, 1500, '#00bfff');


    // 3. Unlock Key
    if (!progress.unlockedKeys.includes(game.stageKey)) {
        progress.unlockedKeys.push(game.stageKey);
        progress.unlockedKeys = Array.from(new Set(progress.unlockedKeys));
        showPopup(`'${game.stageKey.toUpperCase()}' Unlocked!`, canvas.width / 2, canvas.height / 2 + 100, 1500, '#00bfff');
    }

    // 4. Mark as completed
    if (!progress.completedKeys.includes(game.stageKey)) {
        progress.completedKeys.push(game.stageKey);
        progress.completedKeys = Array.from(new Set(progress.completedKeys));
        showPopup(`'${game.stageKey.toUpperCase()}' Completed!`, canvas.width / 2, canvas.height / 2 + 150, 1500, '#00ff44');
    }

    saveProgress(); // Save state immediately

    if (game.mode.includes('precoded') || game.mode === 'yourchoice') {
        nextStage(); // Progress to next for both precoded and choice
    } else {
        game.inChoiceMode = false;
        showMenu();
    }
}

function gameOver() {
    player.dead = true;
    game.mode = 'gameover';
    
    // Stop the game loop
    if (game.animationFrameId) {
        cancelAnimationFrame(game.animationFrameId);
        game.animationFrameId = null;
    }

    // Hide HUD/Canvas and show gameover screen
    hud.classList.add('hidden');
    canvas.style.display = 'none';
    gameover.classList.remove('hidden');
    
    document.getElementById('finalScore').textContent = `Final Stage: ${game.stageKey.toUpperCase()} (Wave ${game.stageIndex + 1})`;
    startShake(1000, 10);
}


// --- MAIN LOOP ---

function mainLoop(time) {
    if (game.mode === 'menu' || game.mode === 'gameover' || game.mode === 'shop' || game.mode === 'multiplayer') {
        if (game.animationFrameId) {
             cancelAnimationFrame(game.animationFrameId);
             game.animationFrameId = null;
        }
        return;
    }

    const dt = Math.min(time - game.lastTime, 50); // Cap dt to prevent jumps
    game.lastTime = time;
    const cw = canvas.width, ch = canvas.height;

    // Shield regen from skin buff (debuffed rates applied in catalog)
    const skin = SKIN_CATALOG.find(s => s.id === player.equippedSkinId);
    if (skin?.buffs?.regenRate) {
        player.shield = Math.min(player.maxShield, player.shield + skin.buffs.regenRate * dt);
    }

    // White hole update
    updateWhiteHole(dt);

    // 1. Update Game State
    game.timer -= dt / 1000;
    if (game.timer <= 0) {
        gameWin();
        if (game.mode !== 'menu') {
             game.animationFrameId = requestAnimationFrame(mainLoop);
        }
        return;
    }

    // Player movement update (using simple mouse follow for now) - FIXED: dt normalized
    const lerpFactor = 0.1 * (dt / 16.67);
    player.x = Math.max(player.radius, Math.min(cw - player.radius, player.x + (mouse.x - player.x) * lerpFactor));
    player.y = Math.max(player.radius, Math.min(ch - player.radius, player.y + (mouse.y - player.y) * lerpFactor));

    // 2. Attack Spawning - FIXED: Timed spawning, special for !
    if (time - game.lastSpawnTime > game.spawnInterval) {
        spawnPatternForStage(game.stageKey);
        game.lastSpawnTime = time;
    }

    // 3. Update Attacks and Check Collisions
    game.attacks = game.attacks.filter(attack => {
        // Base movement - FIXED: Consistent dt
        if (attack.update) attack.update(dt);
        else {
            attack.x += (attack.vx || 0) * (dt / 16.67);
            attack.y += (attack.vy || 0) * (dt / 16.67);
        }

        // Collision Check
        const attackRadius = attack.radius || 10;
        
        let collision = false;
        if (attack.isColliding) {
            collision = attack.isColliding(player.x, player.y, player.radius);
        } else {
            const dx = player.x - attack.x;
            const dy = player.y - attack.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            collision = dist < player.radius + attackRadius;
        }

        if (collision) {
            const damage = attack.damage || 5;
            let finalDamage = damage;

            // Dragon reflect special (fixed: angle check, no shield cost on reflect)
            if (player.equippedSkinId === 'v2_dragon' && player.shield > 0) {
                const dx_pos = attack.x - player.x;
                const dy_pos = attack.y - player.y;
                const dist_pos = Math.sqrt(dx_pos * dx_pos + dy_pos * dy_pos);
                if (dist_pos > 0) {
                    // Hit angle
                    let hitAngle = Math.atan2(dy_pos, dx_pos);
                    if (hitAngle < 0) hitAngle += Math.PI * 2;

                    // Shield arc
                    let shieldStart = player.skinState.dragonShieldAngle % (Math.PI * 2);
                    if (shieldStart < 0) shieldStart += Math.PI * 2;
                    let shieldEnd = shieldStart + Math.PI * 1.5;
                    let wraps = shieldEnd > Math.PI * 2;
                    shieldEnd = shieldEnd % (Math.PI * 2);

                    let covered = wraps ? (hitAngle >= shieldStart || hitAngle <= shieldEnd) : (hitAngle >= shieldStart && hitAngle <= shieldEnd);

                    if (covered) {
                        // Reflect
                        const nx = dx_pos / dist_pos;
                        const ny = dy_pos / dist_pos;
                        const dot = attack.vx * nx + attack.vy * ny;
                        attack.vx -= 2 * dot * nx;
                        attack.vy -= 2 * dot * ny;
                        // Repel away
                        attack.x += nx * (player.radius + attackRadius + 10);
                        attack.y += ny * (player.radius + attackRadius + 10);
                        showPopup('REFLECT!', player.x, player.y - 30, 500, '#ff0');
                        // No damage or shield cost
                        return true;
                    }
                }
            }

            // Normal damage
            if (player.shield > 0) {
                const shieldAbsorbed = Math.min(player.shield, finalDamage);
                player.shield -= shieldAbsorbed;
                finalDamage -= shieldAbsorbed;
            }
            if (finalDamage > 0) {
                player.hp -= finalDamage;
                game.lastDamageTime = Date.now();
                startShake(150, 5);
                // Only show damage popup if damage was actually taken
                if (Math.round(finalDamage) > 0) {
                     showPopup(`-${Math.round(finalDamage)} HP`, player.x, player.y - 20, 500, '#f55');
                }
            }
            if (player.hp <= 0) {
                gameOver();
                return false; // Remove attack on hit
            }
            // Only remove projectile if it actually deals damage, otherwise let passive threats persist.
            if (attack.damage > 0) {
                return false; // Remove attack on hit
            }
        }

        // Lifetime and boundary check
        return attack.lifetime > 0 &&
               attack.x > -100 && attack.x < cw + 100 &&
               attack.y > -100 && attack.y < ch + 100;
    });

    // 4. Draw Everything
    ctx.clearRect(0, 0, cw, ch);
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, cw, ch);
    
    // FIX: Use ctx.save() and ctx.restore() to contain the screen shake translation
    ctx.save(); 

    // Apply shake offset
    const shakeX = Math.random() * game.shake - game.shake / 2;
    const shakeY = Math.random() * game.shake - game.shake / 2;
    ctx.translate(shakeX, shakeY);

    // Draw White Hole if active
    if (game.whiteHole) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(game.whiteHole.x, game.whiteHole.y, game.whiteHole.radius, 0, Math.PI * 2);
        ctx.fill();
    }

    // Draw Attacks
    game.attacks.forEach(attack => {
        if (attack.draw) {
            attack.draw(ctx);
        } else {
            ctx.fillStyle = attack.color || '#fff';
            ctx.beginPath();
            ctx.arc(attack.x, attack.y, attack.radius || 10, 0, Math.PI * 2);
            ctx.fill();
        }
    });

    // Draw Player
    renderPlayerSkin(ctx, player.x, player.y, player.radius, player.equippedSkinId, dt, player.skinState, player.hp, player.maxHp);

    // Draw Shield
    if (player.shield > 0) {
        const shieldRatio = player.shield / player.maxShield;
        ctx.strokeStyle = `rgba(0, 150, 255, ${0.5 + shieldRatio * 0.5})`;
        ctx.lineWidth = 5 * shieldRatio;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
        ctx.stroke();
    }

    // Draw Health Bar
    const hpRatio = player.hp / player.maxHp;
    ctx.fillStyle = hpRatio > 0.5 ? '#0f0' : (hpRatio > 0.2 ? '#ff0' : '#f00');
    ctx.fillRect(player.x - 15, player.y + player.radius + 5, 30 * hpRatio, 3);
    
    ctx.restore(); // Restores context, automatically resetting the translate (shake)

    // 5. Update HUD and Loop
    updateHUD();
    game.animationFrameId = requestAnimationFrame(mainLoop);
}


// --- MENU AND KEYPAD LOGIC ---

function buildKeypad() {
    keypad.innerHTML = '';
    const worldKeys = [...WORLD1_KEYS, ...WORLD2_FULL];

    worldKeys.forEach(k => {
        const keybtn = document.createElement('div');
        keybtn.className = 'key-btn';
        const isUnlocked = progress.unlockedKeys.includes(k);
        const isCompleted = progress.completedKeys.includes(k);

        if (!isUnlocked) {
            keybtn.classList.add('locked');
            keybtn.textContent = '?';
            keybtn.title = 'Complete this stage in Precoded Mode to unlock.';
        } else {
            keybtn.textContent = isCompleted ? k.toUpperCase() : k.toUpperCase();
            keybtn.onclick = () => startChoiceStage(k);
        }

        if (k === game.stageKey) {
            keybtn.classList.add('current');
        }

        keypad.appendChild(keybtn);
    });
}

function startChoiceStage(k) {
    const combinedKeyset = [...WORLD1_KEYS, ...WORLD2_FULL];
    game.keyset = combinedKeyset;
    const index = combinedKeyset.indexOf(k);
    if (index === -1) {
        console.error("Key not found in combined set:", k);
        return;
    }
    game.stageIndex = index;
    game.world = index < WORLD1_KEYS.length ? 'world1' : 'world2';
    
    // Hide Keypad and start game
    keypad.classList.add('hidden');
    startGame('yourchoice', game.world, k);
}


// --- SKINS SHOP LOGIC ---

function showSkinsShop() {
    menu.classList.add('hidden');
    shop.classList.remove('hidden');
    renderShopCatalog();
}

function renderShopCatalog() {
    const catalogContainer = document.getElementById('skinCatalog');
    catalogContainer.innerHTML = '';
    document.getElementById('shopCredits').textContent = player.credits;

    SKIN_CATALOG.forEach(skin => {
        const card = document.createElement('div');
        card.className = 'skin-card';
        let buffTag = '';
        if (skin.buffs) {
            buffTag = '<div class="buff-tag">Has Buffs!</div>';
        }
        card.innerHTML = `
            <h3>${skin.name} - ${skin.price} CR</h3>
            <div class="preview"><canvas id="prev_${skin.id}" width="50" height="50" style="background:#111; border:1px solid #333; image-rendering:pixelated;"></canvas></div>
            <p>${skin.desc}</p>
            ${buffTag}
            <div class="actions"></div>
        `;

        const actionsDiv = card.querySelector('.actions');
        const isOwned = progress.ownedSkins.includes(skin.id);
        const isEquipped = player.equippedSkinId === skin.id;

        if (isEquipped) {
            actionsDiv.innerHTML = `<button disabled>EQUIPPED</button>`;
        } else if (isOwned) {
            const equipBtn = document.createElement('button');
            equipBtn.textContent = 'EQUIP';
            equipBtn.onclick = () => equipSkin(skin.id);
            actionsDiv.appendChild(equipBtn);
        } else {
            const purchaseBtn = document.createElement('button');
            const canAfford = player.credits >= skin.price;
            
            purchaseBtn.textContent = `BUY - ${skin.price} CR`;
            purchaseBtn.disabled = !canAfford;
            purchaseBtn.classList.toggle('disabled', !canAfford);
            
            if (canAfford) {
                purchaseBtn.onclick = () => purchaseSkin(skin.id, skin.price);
            } else {
                purchaseBtn.title = 'Not enough credits!';
            }
            actionsDiv.appendChild(purchaseBtn);
        }

        catalogContainer.appendChild(card);
    });

    // Render previews on canvases
    SKIN_CATALOG.forEach(skin => {
        const prevCanvas = document.getElementById(`prev_${skin.id}`);
        if (!prevCanvas) return;
        const pctx = prevCanvas.getContext('2d');
        pctx.clearRect(0, 0, 50, 50);
        const mockX = 25, mockY = 25, mockR = 8;
        let mockState = {};
        if (skin.id === 'cat_txt') mockState = { catBlinkTimer: 0, catBlinkDuration: 1200, catFace: 'owo' };
        if (skin.id === 'periodic') mockState.periodicElement = getRandomPeriodicElement();
        if (skin.id === 'arcade') mockState.arcadeFlicker = Array(16).fill(false);
        if (skin.id === 'grok_xai') mockState.grokAngle = 0;
        if (skin.id === 'v2_dragon') mockState.dragonShieldAngle = 0;
        if (skin.id === 'retro_term') mockState.retroBlinkTime = 0;
        // Add more inits as needed
        renderPlayerSkin(pctx, mockX, mockY, mockR, skin.id, 0, mockState, 50, 100);
    });
}

function equipSkin(skinId) {
    player.equippedSkinId = skinId;
    applySkinBuffs();
    saveProgress();
    renderShopCatalog(); // Refresh shop view
    showPopup(`Equipped ${skinId}!`, canvas.width/2, canvas.height/2, 1000, '#00ff44');
}

function purchaseSkin(skinId, price) {
    if (player.credits >= price) {
        player.credits -= price;
        progress.ownedSkins.push(skinId);
        player.equippedSkinId = skinId; // Auto-equip on purchase
        applySkinBuffs();
        
        saveProgress();
        renderShopCatalog(); // Refresh shop view
        updateHUD();
        
        showPopup(`Purchased & Equipped ${skinId}!`, canvas.width/2, canvas.height/2, 2000, '#ffeb3b');
    } else {
        showPopup(`Not enough credits!`, canvas.width/2, canvas.height/2, 1000, '#f55');
    }
}


// --- EVENT LISTENERS AND INITIALIZATION ---

let mouse = { x: 0, y: 0 };
window.onmousemove = e => { mouse.x = e.clientX; mouse.y = e.clientY; };
window.ontouchmove = e => { if (e.touches.length > 0) { mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; e.preventDefault(); }};

window.onresize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
};

// Keyboard controls for spinning shield (Q/E for dragon)
document.addEventListener('keydown', (e) => {
    if (player.equippedSkinId === 'v2_dragon') {
        if (e.key === 'q' || e.key === 'Q') {
            player.skinState.dragonShieldAngle -= 0.2;
        } else if (e.key === 'e' || e.key === 'E') {
            player.skinState.dragonShieldAngle += 0.2;
        } else if (e.key === 'w' || e.key === 'W') {
            spawnWhiteHole(); // W for white hole activation
        }
    }
});

// Menu Button Wiring (FIX: Always start at stage 0 for Precoded modes)
precodedBtn.onclick = () => { 
    game.stageIndex = 0; 
    game.stageKey = WORLD1_KEYS[0]; 
    game.inChoiceMode = false;
    startGame('precoded', 'world1', WORLD1_KEYS[0]); 
};
precodedUniBtn.onclick = () => {
    if (!progress.world1) { // World 2 requires World 1 completion
        startShake(300, 8);
        showPopup('Locked: Complete World 1 first!', canvas.width / 2, canvas.height / 2, 2000, '#f55');
        return;
    }
    game.stageIndex = 0; // FIX: Ensure stage index is reset
    game.stageKey = WORLD2_FULL[0]; 
    game.inChoiceMode = false;
    startGame('precoded-uni', 'world2', WORLD2_FULL[0]);
};

// Your Choice Mode button now correctly opens the keypad as checkpoint
yourChoiceBtn.onclick = () => {
    game.inChoiceMode = true;
    showMenu(); // Shows menu with keypad and hides main buttons
};

skinsShopBtn.onclick = () => {
    game.inChoiceMode = false; // Reset to main menu state when entering shop
    showSkinsShop();
};
shopBackBtn.onclick = () => { 
    game.inChoiceMode = false;
    shop.classList.add('hidden'); 
    showMenu(); 
};


// Key R restart
document.addEventListener('keydown', e => {
    if (e.key === 'r' || e.key === 'R') {
        player.hp = player.maxHp;
        player.shield = 0;
        player.dead = false;
        game.attacks = [];
        game.inChoiceMode = false;
        showMenu(); // Use the dedicated function to clean up and transition
    }
});

// Initial Setup
window.onload = function () {
    window.onresize(); // Set initial canvas size
    showMenu(); // Ensure the menu is shown initially and the game loop is stopped
};

</script>
</body>
</html>
